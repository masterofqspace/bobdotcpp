//     6d3cts3d7s4hkdtc2c8c3h8sjh9sthks5dqdtd7c3sasqsad8h6ckcqhac8d6h7h2hahjdkh2s9c4s5h4d7d6sqc9h5s4c9djc2djs5c                                                    //d
//     6d3cts3d7s4hkdtc2c8c3h8sjh9sthks5dqdtd7c3sasadqs8h6ckcqhac8d6h7h2hahjdkh2s9c4s5h4d7d6sqc9h5s4c9djc2djs5c                                                    //d
// all cpp compilers ms developer studio z86    
////////////////////////////////////////////////////////////////////////////////////////////   
//  cost per bit preliminary analysis                                                          
//                                                                                             
//  5 cpu instructions per bit     
//  the refillium cost averages O(1/2) cpu instruction per bit                              
//  the capital pee definition of blasphemy is n o t c o u n t i n g                           
//  my entire life has been n o t r a n d o m b u t j d p 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
unsigned long phrymes[] = { // cycle decomposition length is ten to the seventy    
					2, 25057,  7643,  5711,  2767,  6857,  8971, 18089, 15797, 31333,
	30323, 24179,  4861,  5783, 17027, 30091,  1693, 32507, 15683,  8539,
		7573, 32261, 10601,  6221, 19051, 15289,  2300, 28477, 25621, 21859,
		2380,  3159,  8641, 30931, 12697, 11909, 17707,   463,  3797,  3299,
		3607,  2311, 14827,  5987,   271, 22123,  5869,  6791,  9227, 24979,
	28901,  7069, 19141, 29989,   167, 14173,  1741,  3727, 31543, 17389,
		4799, 30497,  3559, 27791, 26981, 23827,  3209,  8761,  6053, 11981,
		5689,  1583,  6907,  1217, 20593,  8167, 31481, 11789, 29881, 19219,
			101,     5,  6329, 20431, 22369,   491,  7489, 31643, 11177, 28493,
		7507, 18127, 28229,  9833, 25999, 10729, 24247,  1277, 26431,   347,
	26647, 10559,  2269, 17791, 28387,   733, 21991, 28657,  9419, 32381,
		2011,  9973, 14081, 10111, 10979, 13829, 13723, 14051, 18443,  2663,
	23603,   547, 24509,  9941, 28729,  2447, 26953, 23039,  4919, 21163,
	20879, 13763, 12097, 18287, 25763,  3001, 19309, 28279, 32119, 12379,
	26759,  8059, 21821,  1187, 17971, 32089, 28663, 26959,  2441, 21433,
	30307, 13093,  2887, 15641, 24473, 32063, 24611,  7417, 32057, 30763,
	12281, 14449,  7753,  3539, 28517,    53, 10151,  5119, 17383, 15101,
	21013, 32299,  2851, 21587, 22679, 27773, 13627,  8053,  2141, 20551,
		5197, 21799,  4649, 20749,   977, 19387, 20983,  1933,  4027,   251,
	10301, 26161,  2333,   997,   769, 13147, 13463, 25261, 31793, 32309,
	10501,  8783, 21001, 24671,  5683, 18353, 13883, 28001, 23197, 13913,
	18379, 26339, 22613, 16927,  8243,  8123, 10463, 25357,   953, 20483,
		6701, 27281,  1129, 21467,   521, 12491,  6073, 24239, 15787, 29153,
	22651, 28621,  2389,  5333,     7, 22133,  3331, 12251, 20261,  6781,
	32443,   103, 28909,  7937, 29599,  5323,  8861, 11279, 12227,  6833,
	30491, 32003, 11093,  5087,  6359, 10903, 31513, 30013, 22279,  4933,
		6637,   149, 16231, 14731, 31079,  2833, 14503,  3121,  3191, 32069,
		4127, 14159, 17609,  9463, 16603,  8329,  3527, 23021, 25147, 15919,
	11549, 26717,  3307,  8443, 13487, 24421, 14843,  5147, 14549, 25741,
	21023, 10103,  4673, 15373,  6967, 31159, 30071,  8819, 16319, 32141,
	18919,  1597, 32687, 20693, 30517, 27943,  5393, 19457, 13163, 16063,
		4003,  1567, 22343, 25541,  1627, 12653, 31727,  6719, 32531, 28309,
	17203,  5849, 32359, 11329, 17033,  5801, 22787, 14939,  7129,  1153,
	16361,  1447, 15889, 16301, 22153, 24841,    83, 15607, 22159, 12917,
	32143,  7901, 20681, 13267, 32083, 19553,  5581, 28499,  4259, 10337,
	17891,  2999, 21787, 10973, 11743,  1319, 23269,  1669,   937,  7879,
		9239,  1213,  9871, 14551, 15199,  6871, 14747,  1249, 15937,    43,
		9341, 10529, 12113,  2543, 19403, 16057, 13327,  9161, 20117,  9157,
			461, 14779, 14771, 29567, 24593, 12583, 21401, 30803, 29389, 31151,
	19249, 17393, 27799, 28867,  9661, 12487, 24847, 13177,  8807, 13859,
	11447, 26249, 27817,  8233, 28649, 15091, 12269, 23753, 13063, 31687,
		3137,   277,  3533,  4001,    17, 10837, 26177, 14683,   647, 15973,
	18701, 12899, 18793,  8969,  5441, 13297, 17539,  9629,  4519, 19333,
	25349, 11497, 14437, 24091,  8689, 14753, 30949,  7321, 15581,  4153,
	32647,  8629,  5903,   313,  9343,  5009, 10009, 29537, 14149,   947,
	12109, 26947, 30097, 17981, 31723, 25747, 28631,  5209, 22859, 17093,
	29251, 26597, 21529,  8731, 19687, 21649, 22051,  7607,  8237,  3061,
			641, 16253, 17053,  4049, 25411, 30893, 15299,  9001, 11213, 11699,
		1049,  2297, 11839, 19087, 25253, 16657, 23767, 32117, 24953, 15497,
	29531, 14929,    71,  3067,  1117, 15061, 24691,  2113, 30871, 15619,
	16127,  2969, 10883, 27793, 24889,  5791, 30509, 30139, 22921, 26021,
		5749,  7247, 12547,  7933, 31649, 10459, 12323,  2383,  9851,  7547,
	17047, 10333,  1259, 13679,  1097, 10499,  7951, 11317,  5851, 14867,
		2677,  2777,  2689, 27067,  4339, 15137, 31033,  5591,  8999, 16661,
	18191,  6869, 13921,  1409, 12613, 25127, 14519, 30493, 31177, 10723,
	23099,  2671,   331,  7103, 18289,  3359, 24407, 10613, 27481, 24923,
	12853, 12391,  5939,  1123,  9181, 14423, 27941, 16729, 22619, 21559,
	19507, 23057,  3511, 15451, 18169, 28591, 22669,   137, 18637, 24329,
		4801, 21061, 26711, 29243, 15139, 10133, 15649, 10709,  9059,  8753,
		8269, 11311, 15349, 18307, 26437, 18371,  3391, 10831, 18097,  5701,
	19301,  4973, 14621, 27073, 25997, 32027, 17569, 15401, 19163,  6121,
		6997, 28807, 20233, 24371, 17713, 11383,  4409,    67, 32321,  2069,
		3251, 10093, 19373, 15733, 32099, 28283, 29383, 18301, 17341, 14717,
	19289, 13183, 16333, 10639,  7873, 18731, 23473, 11243, 16741,   353,
	12979, 29209, 25601, 23957, 29027,  9337, 25759, 29147, 11159, 15259,
	14419, 28703, 17939, 19571, 10607, 13523,  9413, 22637,  4139, 24049,
	17509,  1493, 26297,  1279,  1667, 10667, 21221,  4219,  3847,  3023,
	10069,  3943, 29473,  6037, 13681, 20921,  4327, 20047, 21019, 27241,
	20173, 23773, 30341, 29101, 10939,  7159,  5351,    47,  7559,  4493,
	26017, 13649, 21589, 26879,   991,   113, 29959, 27127,   751, 28219,
		1013, 23053,  6841, 18523, 23909,  1289, 14851, 12373, 29863, 17929,
		6197, 18481, 27701, 14087, 12049,  2143,  2693, 24763,  6163,  9283,
		1223,  6079, 32713, 28949, 30631,  2803, 31847,  2549, 29423, 10067,
	15991, 20947,   719,  7829, 18427, 18043, 16033, 29723, 26141,   839,
	19069,  7793, 24029,  8467, 13127,   599,  1489, 32303,  1657,  3169,
	23189, 24103, 20347, 13219,  8297,   673,   401, 32609,  4813, 28319,
	16703, 24121,  7741, 21911,  2503,   691,  2539, 30469, 25819, 22091,
		3089, 25307,  9209, 21517, 19157, 23509, 17159, 17167, 25771,  5153,
	26387,  4211, 28541,  4787, 27271,  5279, 32579,  2579,  4951,   107,
		4937,  3733, 10453, 25693, 19889, 22993, 14639, 23977,  4261,  6101,
		7517,   457, 13003,  7621, 29009, 23339, 19891, 12763, 29023, 28597,
		7369, 10889,  2393, 29983, 10651,  6481,  5167, 11113, 30029, 21101,
		4877, 18787, 21487, 24019,   367, 12007,  1867, 12511, 23629,  6143,
		9431,  8087,  3259, 29401,  1061, 32251,  2417, 18367, 16787,  7297,
		2371, 19541,  9127, 25391, 30809, 29077, 13103, 14951, 24499,  7561,
	18661,  9013, 24001, 18233, 22853, 16979,  8597,  1811, 17921, 27893,
	24481, 25717, 21383,  1619,  9697, 14741,  5347,  5437, 14759, 22367,
	19447, 11287, 25183, 13807, 14983, 26497, 27749, 22483, 22783, 11503,
	13337, 18217,  5099, 12823,  3433, 17041, 19753, 24917,  5417, 10039,
	20021,  8839,  9679, 16547, 13903, 19259,  7883,  7681,  2707, 29527,
	16097,  2657, 19991, 18461, 31271,   607, 17333, 21773, 23929, 17581,
	10391,  3643, 23893, 13907,  8179,  4549, 10799,  6689, 31337, 16363,
	10247, 16139,  9029, 20627,  1783, 23531, 20849,  1951, 28871,  8293,
		6959, 31477, 12157,  3571,  6983, 28351, 10259, 18797, 23567,    97,
	28183,  2473,  3329, 25919, 20887, 18257,  5737, 10657,  3529, 29483,
	16451,  4909, 12829, 17099, 29411, 17489,  9479, 32077, 31883,  3907,
	15767,  7603,  4567,  2213,  8017,  4993, 21391, 30137,  5179, 22777,
		9743,  3547,  1373, 16981, 17387, 31307, 27011, 24113, 13457, 13721,
	13901, 19211,   601, 24469, 24077, 25453, 30169, 27449,  3557, 15803,
		4603, 28099,  9203,  2927, 28019,  6421,  9547, 11369,  7727,  6131,
		9601, 10343,  6491, 31387,  2719, 18947, 21187, 21611,  2377, 28201,
	24547,  6761, 29837,  5449, 16931, 31051,  3373, 10691,  7019,  6043,
		6977,  3187, 12973,  1181, 28723,  2551,  4111, 31081,  4357, 20359,
		3347, 12911, 15809,  5813, 27953, 28111, 11527,  4057,  4217, 29179,
	32563,  5861,  7723, 31139, 27031, 27689,  1733, 23819,  9859, 30389,
		9817, 30133, 16937, 10099, 26501, 12889, 13411, 27803,  2729, 26209,
	23117, 18433, 21521,  6829,  5839, 22741, 31973, 31321, 22409, 14281,
		4363, 13291, 21157, 32633, 32257, 11321, 26399,  1979, 30113,  1399,
	16889, 24533,  5743,  1571, 19433, 18839,  6659, 15671,  2801, 21997,
	17837, 25463,  6691,  3323, 21419,   479, 22433, 32749, 14557, 14737,
	26891,  3613,  8263, 16189, 25121, 11969, 19763, 23669, 25457, 32611,
	13691, 22307,  8849,  9391, 13451, 27479, 18749, 30553, 22013,  1459,
	27581, 11443, 28411, 27779, 29131,  8779, 31607, 24919,  1291, 12433,
	25579, 16087,  7307, 15511, 23497, 29581, 12377,  3407, 21601,  6113,
		6581,  6599, 26641, 17377, 21107, 10243,  2309, 17491, 20959, 12119,
	32423,   487,  8209, 29741, 12479,  2131, 20663,  1019, 24071, 28789,
		9533,  9257, 24359, 21961, 14401,  7993,  2647,  4733, 27437, 28843,
			727, 24181,  4159, 11057, 29867,  9643, 21407, 18143, 20507, 26099,
		4547, 14071, 31957, 16369,  1231,  6607,  7649, 16631, 22481, 12671,
	32059, 28349,  7759, 18131, 11299, 25561, 25903,  8929, 12503, 17827,
	15667, 11353, 29339, 24809,  8669,  7529,   337, 32693,   139, 10859,
	30187, 12413,  6067,  1709, 14593,  7187,  9221,  3229, 23561, 15269,
		3469,  7717,  6203, 13187, 15817, 13669, 31181, 17257,  7027, 16111,
	21059, 19597, 17207, 29201,  1039,  6709, 28081, 23063,  3767,  8101,
	17497, 25471,    61, 31907,  7523, 10711,   383,  1453, 18041,   229,
	28933, 30727, 24977, 11903,  7177, 14657,  6427,  6949,  9749, 20543,
		6311,  4663, 13877, 14057, 19477,  8867, 13933,  2903,  1601, 17183,
	28277, 18049, 31663, 26053, 24391,  5107,  6883, 10513, 24061, 26171,
	26357,   541, 17519, 20023,  6271,   659, 27823,  9403, 12953, 30911,
	26993, 17401, 31063, 10399,   617, 12161, 30427, 31393, 30047, 20981,
	31219,  2063, 21683, 16103, 17419,  9539,   797,  6793, 32237, 14249,
	12401, 10853, 17011, 26777, 20399, 25111, 22277, 12637,  1433, 20407,
	26309,  6343, 28603, 27653, 25423, 25031,  6389, 25793,  7841, 21347,
	17989,  4969,  5953, 17573, 17729, 20269, 16453, 26321,  6469,  1663,
		7757,  4931,  1699, 29833,  4999, 22769, 26423, 21599, 31741, 17909,
		1747,  3719, 19973, 14831, 30637, 29137, 20389, 20707, 27541, 24229,
	13781,   307,  6653, 31769, 18149, 22541, 17881, 25969,  1993, 16267,
			281,  6679, 22073, 14947, 23143, 15377,  2003, 20963, 27277,  6961,
	24821, 17189, 22691,   467,  6553, 26863, 19379, 16249,  8069,  6211,
		9857, 29173,  9067, 13109, 22573, 18253, 16673,  1009, 25841, 12517,
	13469,  2819, 20287, 13537, 15661, 19471, 22171, 31253, 31189,  8111,
	20011,  3253, 10739,  3917, 24439, 11887, 21841, 22441, 20063,  6737,
	27043, 30773, 18439, 18541, 21563, 25229, 17747,  6991, 28163, 29641,
	16061,  4177, 19073,  5639,  3853, 23633, 17551, 11083, 27739, 12197,
	12343, 23663, 19489, 18539, 27077, 24631,  4513, 15131, 24137, 23327,
		8161, 12743, 12739,  2683, 16067, 30649,  5231, 29851, 10597,   163,
	18959,  5051,  5003,  2687,   193, 26861, 13099, 16567, 27017, 28097,
	31231,  9623, 15749,  2699,  1451,  7487, 32233, 15679, 26731, 11681,
	22157,   311,     3, 15439, 27143,   809,  3361,  8389,   439, 11131,
		9439,  5651, 18413, 30697, 11261, 32573,  1721,  2617, 17239,  4721,
		6379,  3823, 17477, 31771, 16759, 31517, 32533,  3851,  3691, 19801,
	10891, 11897,  4051,   211,  9511,  2557, 15913, 13967,  5399,  4457,
		1439, 23131,  2659, 20789,  1987,   569,  1871,  8627, 21557, 10987,
	14489, 17029, 18047, 26111, 27917, 29017, 10937,  3461,   499,  1021,
	28307, 10993,  7193, 14821, 13931, 31547, 23159, 24989, 12799, 10589,
		6257, 14897,  2971, 13513, 30319, 21803, 19267, 10427,  9689, 14083,
	12539, 13049, 16349, 25343, 28513, 17783,  5927,  5741,   239,  1723,
			563, 22303,  8831, 14783, 14207, 15383,  1889,  4643, 14653, 13613,
		2083,  4639, 15217, 25703,   443, 16963, 17107, 23311, 28069, 25801,
			349, 27751, 13687, 21169, 27367,  1051,  5897, 30467,  1327, 13789,
		8609, 19949, 26921, 29429,  8677,  9931,  7687, 16487,  5101, 22147,
	15877, 12703,  8837, 11467,  2939, 30347, 29347, 25867, 13441,  1879,
	27611, 24203, 20639, 26839,    59,  8693,   293,  6269,   269, 16987,
	20441, 10211,  6971, 15313,  5309,  8429, 27527,  3271,  5443, 24859,
	32719, 21523, 19483, 21977,  2593, 28627, 28051, 18911, 28087,  8647,
	28607, 11831,  2243, 10847,  4903, 22397,  2731, 25633, 25951,   109,
	12041, 12107, 21713, 23563, 10789, 19927, 25321,  6337, 16829,  7219,
		8147,  9721, 23173, 16943,  9739,  1907, 11423,  6577, 30559,  3659,
			739, 32189, 26821, 22349, 31729, 15161,  5981, 22109, 16417,  9787,
	12497, 30089, 30119, 15083, 19139, 19427, 29753,  4637, 23719,  6151,
			787, 25097, 28921, 14029, 26893, 21193,  1303, 30293,  8117, 27673,
		2221, 19777, 20809,  8707, 10457, 19441, 24223, 18679,  3257, 17789,
		5531, 21283, 19609,   881, 30817, 11677, 25073, 23743,  7109, 30557,
	16217,  8951, 14923,  9049,  8219, 27103,  8377, 30211, 26833, 11783,
	21067, 13159, 20873, 11987, 10193, 13249,  6091,  6287, 25657, 19793,
	27827,  6763,  4657, 25679,  3221,  2089,  7043, 17863,  5113, 31069,
	23677, 20393,  5641, 11863, 15881, 25537, 16883, 15473, 15731,   757,
	25447, 12347, 24413, 23671,  3083, 12163, 18223,   919, 29333,  3041,
		4597, 32191, 11197, 12689,  2797,  7703,  8011, 30937, 15329,  8599,
		3457, 19001, 31259, 32401, 32569, 28619, 13367, 12713, 12619, 11617,
		7433, 21499, 19543, 16381, 16141, 17903, 21503,  4421, 14543, 13591,
		9811, 29873, 16831, 24851, 10091, 21277,  2039, 16427, 29803, 21929,
	26737, 29303,  7817,  7577, 20443, 12421, 32411,  5407, 32491, 30403,
		1499,  2339, 18691, 23027,  2531, 27457, 18121,   181,  1949, 13229,
	24781, 14561, 18713, 26561, 26699,  4297, 26227, 22469,  7237, 28433,
			709, 16529,  4349, 14431, 19531, 16519, 17659, 12907, 31147,  8923,
		9929, 14447, 11939, 20297, 19213, 12919, 18773, 18119, 30839, 23869,
	32369, 19577, 23017, 15493,  3467,  8447, 14957,  3491, 31267, 24097,
	14369, 10861,  2267, 23857, 12941, 23789, 20411, 24251, 25243, 11633,
	11959,  4241, 24527, 26489, 31013, 23899,  8287, 23981, 25889, 13711,
		3911, 26729, 23887, 26237,   283, 16553, 31567, 32051, 13171, 27107,
	23599,  2897, 29819, 27583, 16411,  9613,  9323, 14407, 30853,  2239,
		3203,  4691, 13759, 12451, 31489,  4201, 18553, 10567, 28961, 30161,
	16699,   127, 16843, 13009, 11393,  5867, 31699, 14767, 22111, 11953,
	23557,   761,  1093,    41, 29683, 10037, 19463, 18913,  1069, 29611,
	10177, 15959, 28409,  8963, 27551, 29453, 20177, 15907,  4871, 25153,
		7253, 15287, 32009,  3617,  3989, 18503, 15727, 25643, 16619, 11437,
	19709, 12289,  4391,  4651, 21377, 31039, 10433, 19841, 22621, 27239,
	10949, 21017, 15467,  4987,  5717,   821, 20743, 17443, 25673, 23201,
		8093,  8369, 11807, 10957, 30253, 29663, 28859,  3929, 30431, 22271,
		5477,  1063, 24677, 28403,  7499,  7477, 27983, 17851, 25303,  3037,
	32377,  6047,  4273, 28771, 25943, 31223,  6217, 11813, 27059, 30869,
	20147,   389, 24043,  2381, 20071, 32707, 26449,  4523, 28837,   571,
		5297,  4243,  7691,  2347, 30977,  5827, 20771, 22807,  7211,  6779,
	25873, 12457, 24107,  6547,  1033, 17351,  2411, 15319, 20479,  7673,
	28559, 12809, 11867, 12589, 13309, 14143, 29789,  9011, 23689, 26633,
	14153,  1321, 22037, 29063, 15107, 20897, 25373, 25523, 27997,  7351,
	23291, 11821, 27253, 24007, 12101, 31849,  5233, 22943,  3697,  7457,
	20929, 10331,  3449, 21179,  1483,   911, 26513, 32503, 20807,   701,
	14869,  3709,  1237, 15361, 11833,  1973, 10289, 31319,  8887, 10267,
	10169, 22721, 14327,  5081,  5303, 27697, 22739, 17431,   131,  9311,
	32621,  4967, 26591, 17137,  6373, 22709, 16747, 16447, 23293, 20599,
	17231, 28751, 12329, 19997, 30197, 22871, 27211, 21757, 17359, 30677,
	14323, 15031, 16633,  4507,  4229, 29129, 23447,  1523, 20353, 23741,
		4729, 31249, 10061,  4723,  7451,  7229,  1901,  7331, 25013,    13,
	21569,   503, 23011,  9091,  1607, 29123, 12253, 11597,  8737, 22549,
		3541,  5843, 26627, 30011,   829,  6563,  8581, 19751, 13477, 27409,
	21943, 19183,  2203, 13841, 27847, 27397,   421,  4517,  3833, 21851,
		1361, 22447, 17327,  1307,  9619,  2609, 30707, 16871,  8821, 23227,
	23059, 32587, 25309, 31891, 19853, 20899,  7537, 19009,  9497, 25849,
	22877, 27191, 16073, 32653,  1759, 28573,  7213, 17483, 20089, 14887,
	13331,  3181, 13697, 20113, 31859, 27539,  6823, 19727,  3583, 28181,
		3673,  7243, 17417, 10531, 22079, 22727, 18493,  2087, 21317, 24023,
	13151, 12577, 30203,  2287, 14879, 26417, 27947, 25583,   877,  2749,
		5519, 14633, 15307,   743, 13499, 26903, 28447, 11087, 17291, 21701,
	19079, 15331,  1697, 27197,  3079,  5023, 31721, 16493, 13693, 22501,
		3677, 31573, 10139, 11587,  6551, 26681,  9319,  1787, 13997,  6367,
	30593, 22027, 14011, 26293, 15461, 24749,  6733, 28463,  5501,  4583,
	18803, 28211,  1151, 10781, 29717, 12527,  5573, 11779,  2909, 24571,
	27737, 26203,  1801,  2459, 23539,  1621, 20333, 12301, 13963,    11,
			619,  2357, 20549,  2137, 27743, 27919, 29587, 29437, 19717, 18521,
		7001, 29671, 19603, 29363, 26107,   419,  1531,  7541, 11657, 28793,
	29927, 11923,   317, 10079,  9277,  9781,  8573, 20641, 23431, 23029,
		2591, 10223, 25439, 29759, 23167, 29297, 21839, 23203, 31657, 21341,
	13799,  3631, 22189, 10007,  4283, 31991,  4561, 25847,  3779, 17321,
	12149, 18617, 15359, 21319,   263,  5479, 20327,  3109,   887,  5381,
		5857, 30181, 12011, 14627,  3343,  4337, 16223, 22391, 23687,  6247,
	19429,  8537, 25469, 32717,  2467, 24623, 10753,  2161,  7583, 17737,
			577, 19861, 29287, 21661, 18329, 30661, 11059, 23369, 29633, 31019,
		8221, 19121, 13397,  4157, 11399, 16421, 23747, 20521, 13879,  6011,
	23761, 12923, 13339, 21613, 27617,  6449, 11149, 32371, 31981, 30109,
	11489, 26539,  9769,  5471,  2179,  5657,  1579, 14321, 26687, 10909,
	13037, 21739, 19237,  4079,  4397,   587, 25981, 24907,    89,  4271,
	11351,  3517,  6007, 21149, 11971, 26479, 29947, 26041, 25367,  1997,
	22643,  3301, 15227, 14797,  5237, 15121, 24683,  5659,  8191, 27109,
	22291,  9521, 24877,  2293, 16607,  8543, 28289,  6451,  7789, 10771,
	31751, 24697, 30529, 29221, 30983, 17299, 18397, 27509, 23623, 28697,
	17923,   173, 22129, 15737,   773, 22511,  2857, 17293, 15149,  6473,
	21211, 32341, 22543, 26459, 20611, 15187, 28109, 19583, 20219,  4231,
	18199,  3761, 25931, 32203, 27961, 17021, 13633, 23209, 24517,  6089,
	23971, 26371,   653, 15791, 15583, 26251,  7151, 19681,  8527,   257,
	24133,  3923, 11047, 32413,  8089, 13831, 32297, 28661, 26261,  8719,
	13417, 11117, 32603, 15233, 20231, 17117, 29573,   857, 17911,   509,
	17957,   199, 15823, 23357,  4463, 18341, 16561, 15761, 12781,  5669,
				37,  3593, 12263,  1777,  5227,  4373,  9043,  4943, 17467, 26263,
	15859,  2029, 26693, 25609,  5647, 14197, 18869, 14387, 29443, 26987,
	22247, 16651, 22259,  6173,  2423, 32159, 24443,  5821, 20249, 15017,
			233, 11411, 27337, 18313,   197, 19013, 19501, 11933,  6299, 12073,
	26183,  9187,  1163, 25589, 15647, 23873, 27091, 28571,  6521, 17761,
		9349, 18757, 16007, 11593, 31667, 18583,  3671, 20123,  7079, 18211,
	15527,  9377,  8353, 11251, 31531, 28151,  3463,  3947, 31583,  9151,
	24317, 12611, 16693,  9461, 14723, 19273, 21871, 18269, 15241, 14813,
		5387,  1283, 12043,   907,  8387,  6569, 18899, 23537, 10321,  8521,
	11119,  1109, 11801, 30971,  4447,  3803, 19207, 17669,  1087,  3931,
	19231, 31963,  2477, 13121, 22697, 19759, 32213,  9923,  1553,  9437,
	11941, 23609, 23549, 30223, 20759, 14293, 16229, 20161,  9719,  6911,
		5923, 23627, 12241, 29501, 25799, 21313, 18451, 16193, 17579, 29167,
	15193, 14009, 12203, 11161, 13709, 25087, 12143, 24659,  8009, 18743,
	19979, 21577, 19813, 17077, 24197,  3011, 28537, 12959,  2351,  1423,
		8933, 11491, 11719,  9103,  8623,  5273, 12239, 20323,  9631,   223,
	26669,  3821, 22901, 30241, 20051, 28031,  4007, 32353,  6263,  8039,
	12409,  7823, 18671, 30449,  8311, 13399, 21379, 15013, 29269, 27901,
	31511,   983,  6947, 30103, 24373,  7919,  6317,  7907, 13873, 30271,
		9829,  6361,  9887,  1999, 15443, 13757, 23593, 17749,  4793, 13259,
	10181, 21617,  7127,  5419, 31397, 11239, 14969,  9587, 11621, 15173,
			449, 16433,   883, 32497,  1831,  5483,  6803, 24083,   523,   157,
	18517, 28687, 32467, 20753, 14347,  1559, 22811, 28439, 24151, 27487,
	30643, 20533,   661, 11519, 23333,  5653, 21269,  2957, 19913,  8363,
	15541, 10477,  2099, 11483, 26849,  7669, 30941, 23879, 26267, 20183,
		2843, 31799,  7927, 30703,  5189,  8431, 20149, 19559,   677,  2111,
	22861,  1429, 25301, 15391,   227,  7121, 21937, 23279,  9397, 23041,
	29327, 16691, 15053, 13729,  8713,  5039,  6703, 27529, 29921,  8563,
	21143, 19843, 20939, 27299, 19661, 14591,  8803, 21893,  8273, 22283,
		7411,  9767, 30859, 16903, 19037, 21491, 12893,  6673,  3167, 32479,
	15887,  7639, 27733, 28711, 18587,  5881, 13577,  9967, 16183, 11827,
				19,  2741, 31541, 12841,  2953,  5527,   593,  2789, 26813,   941,
		1877, 28057, 22031, 32183, 31277, 11701,    29,  1103,  9649,  9907,
		9551, 16811,  4289,  1297, 10631, 27691, 22961,  4129, 19937,  6353,
	28549,  7309,   409,  1753, 29629, 25189, 28759,  7057, 23417,  9677,
		1201, 13001, 17807, 21247, 12037,  3889, 15569,   811, 18077, 23321,
	15971, 13381, 10687, 11027, 25339, 11069, 23087,  8419,  3967,  1873,
	25639,  3863, 26347,  1031, 16091,  7283,  9433,  2237, 20903, 23071,
		7013,  9293, 11071,  6199, 14461,   557, 22973,   431, 22193, 18457,
	20143,  1609,  5077, 26783,  2917, 13043, 29033, 25603, 15271, 30851,
	24943, 22963,  7963, 28879,  9041, 14563, 19381,  1549, 19417,  2437,
	20773, 23917, 24379, 10487, 21089,  5171,  4441, 26003, 10163, 21767,
	21323,  6571, 11273,   863,  9371,  1487, 14177,    23, 13033, 16187,
	19867, 11717,   643, 24971, 17627,  4483, 22039, 10627, 26723, 31123,
		6229, 25033,  2129,  2713, 20857,  4021,  4091, 21863, 22063,  6899,
	18133,  7949,  6661, 11579,  6917, 10429,  2791, 26683, 31121, 29399,
	10273, 14107, 26407, 28669, 27259, 21227, 23399,   859,  1091, 15643,
	22273, 14243,  1847,  5779,  2861, 15773, 13567, 19181, 27851,   827,
		4253, 20029,  8941, 22717, 12473, 20101, 20107, 30757,  3701, 15077,
	18979, 23581, 17317, 21737,   823,  5569, 18311, 15263,  2053, 13999,
	17987, 17597, 20341, 16477, 11171,  3793, 28429, 16879, 21031, 24419,
		1229, 18181, 30259, 23911, 19739,  7699,  1543,  2017,  5623,  9199,
		3119, 24281, 21397, 11471, 22453,  1789, 13553,  3919,  9241, 15073,
	31237, 25169,  6133, 31817, 12757, 20747, 14669,    79, 26927, 25409,
	28643, 11173, 29917,  4817, 25667,  1427, 24767, 32363, 21881,   433,
		8231, 19031,  8863,  9133,  5261,  9733,  3637, 21481, 30367,  4133,
		3217,   179,  2153, 17449, 26573,  2399, 14629, 20369, 14033, 13241,
		1931,  7867, 12967, 17657,   379, 27763, 19423, 31357,  8461,  4889,
	10663,   613, 29311,  9173,  3313,  4099, 20563, 12601, 29879,  2341,
	29669,  3581,  5693,  3371, 14303,   397, 14479, 10159, 16649,  5879,
	12647, 19963,  5021, 23371,  9839,  8081, 25037, 19469,  3319,  7333,
	27967, 24967, 28813,  7349, 22751, 28579, 19919, 14699, 16921, 17977,
			241, 10867, 12821, 32429,  7039, 26119, 12437, 11731, 19699, 21121,
		8317, 13597,  1471, 20201, 22531, 17123,  2753,  3881, 13421,  6323,
	27179, 25939,  9137, 27283,  9901, 19993, 23459,  8681, 25247, 16763,
	29207,  3413, 31247,  2711,  5431,  4703, 16069,  4621, 19697,  9473,
	31469,  3019,  7877, 24793, 22093,  8513, 24799,  2207, 31391, 21751,
		9007,  7459,  1367,  5563, 14389, 22381, 27407, 22699, 31153, 10313,
		5281, 15923, 26801, 20129,  4073, 10141, 27809, 13217, 26393, 26557,
		4759, 26881, 32561, 16001, 16823, 13619, 20357, 10369,  3877, 27647,
		8423,  3499, 27431, 26189, 14221, 18859, 32173, 18401,    73, 17683,
		3623, 18013, 20477, 12721, 12277, 22067, 30841, 12553, 12569, 21493,
	21011, 20719, 28817, 28393,   373, 30313, 15559, 25577, 23081, 31327,
	13313, 30881,  9491, 22003, 29021, 11257, 10357,  9949,  7207, 15427,
		1193,  8741,  2081, 14341, 28123, 18061, 25117,  1511, 12641, 16993,
	27767, 13007,  5503,  2633, 28979,  5507,  6301, 26029, 18593, 11551,
	28927, 12211, 22229,   967, 31379,  8501,  4481, 25163, 24733, 24709,
	30781, 26083, 14251,   971,  4679,   631, 31627,   853, 25171,  5059,
		3049, 23251, 23993, 25933, 30059,  1481, 14713, 17209,  5557,  7589,
		6529, 15601, 22817, 17623, 15277,  9421,  6619, 10733, 15739,  8747,
	24169,  1637, 14891, 12071, 29231, 20509, 23297,  2621, 30539,   929,
	21817,  1823,  5807, 27361,  1171, 17599, 12983, 15901, 19319, 14537,
		4019,  6397, 29059,  4783, 16339, 22639, 18229,  1301, 32441, 15629,
		4957,  4013, 21647, 16481, 11689,  3163,  9883, 12791,    31, 12659,
		1913,  9467, 21191,  3769, 19961, 31183, 22571,  3389, 27631,  4789,
	18251, 14411, 10271, 28297,  8699,  2837, 27061, 30689, 26701, 26113,
			359,  2879, 31873,  9109, 32327,  1613, 11777,  4591, 16901, 17839,
	23831,  3739, 29191,  2281,  2027, 16273, 26951, 26153, 18917, 17959,
		8171,  8291,  4451, 13751, 29569,  2963, 27883, 31193, 19819,  6277,
	31601, 31091, 32029, 22937, 17681,  7853,  4423, 21673, 24551, 22567,
	19081, 25913, 11927, 16573, 21727,  6827,  7549, 25237,  7481, 27329,
	24337, 25733,  8663, 30829,  2521,  9281, 19391, 32537, 28027,  1861,
		4751, 30577, 18719,  6029,  6863,   683, 30713, 22907,  7393, 28547,
		2251,  7591,  5011, 25219,  4831, 30671, 15551, 30391, 20717, 26713,
	29387, 24109, 17191,   191, 20731, 10303, 17471,  1381,  9803, 28753,
	27427,  9791, 29761,   151, 14533, 18973, 23813, 12541, 32323,  8893,
		5413, 21139, 15413, 10253, 23833, 11003, 19421,  4093, 23801,  5521,
	30269 };//pigs identify other nostrils of their friends
//////////////////////////////////////////////////////////////////////
#include <stdio.h> //grampa doihafta    doihafta    the capital file type (FILE*)zero; fopen_s(&graph::colorfile,  fclose are there for now    fucking older folder file
// defines typedefs consts.
typedef unsigned  long num;               /// num foundation of reason about numberz  
const num  one = (num)true;             /// first principle: in the beginning one    
const num zero = one >> one;                 /// one recognizes space 
const num  two = one + one + (one >> one);      /// second principle: two is built upon previous work just like the set of elements from one proton definition 
const num  three = two + one;             /// there /// main result of  my lifes work  more later ... i believe protons may have three quarks                     
const num  four = two + two;             /// 1997,CPM98,2000,2002,2009,2017,2019,2020 with qforms for solving all of pspace, discovered 1997.
const num  five = three + two;           /// bobs favorite number is five and the rest seemed inconsequential 
const num  siv = three + two + one;     /// erasthones favorite number siv say sivsivsiv whenever you see a large thing in the sky  say siv siv siv                      
const num  seven = three + three + one;   /// favorite number of many   eg sev savvy seventhtau    las vegas may market seven in all games much better than they do now                                 
const num  ten = five + five;/// my favorite number is ten and is bigger than gods  thus improving thoughts about truly just what doth greater really meaneth after all   
num lessone(num g) // evolution principle: hold on monkey or die
{ // // zero minus circuitry on register g   zero multiply circuitry. could that be?
	num p = zero; for (p = zero; (p + one) < g; p = ((p + g) >> one)) {} return p; // see epluribusunum
}// i avoid minus negation and sclusive or
num times(num a, num b)
{// one through en reason
	if (a) return b + (times(lessone(a), b));
	else return (one >> one);
}                      
const num onehundred /*totalitarian tothe top*/ = times(ten, ten); // perfed perfed perfed
const num seventhtau = onehundred + times(three, times(three, three));// my favorite prayer is seventhtau    tests with onehundred and twentyseven points could destroy totalitarianism
const num onethousand = times(ten, times(ten, ten)); // top count at work on the job clock onethousand //
const num tenthousand = times(ten, onethousand); // the length of the calender in years // abcd +vision in cosmologyears by ten thousand on the second hand of gods watch  
const num onemillion = times(onethousand, onethousand); // people size of one city when citys finally get the quickvote algorithm in world government onecity onevote
const num onebillion = times(onethousand, onemillion); // once upon a time the poplulation size of earth was onebillion 
#define      when          if 
#define      otherwise     else 
const num sivteen = siv + ten;
const num thirtyone = sivteen + ten + five;
num diagovreason[] = { /*thirtytwo valuable zeroes ninehundredninetytwo agreeable ones                                  */
				/* #P=#Q  number satisfying solutions equals number valid quantifications  (Satisfiability 2002)                    */
				(num)4294967294,  (num)4294967293,  (num)4294967291,  (num)4294967287,/*my favorite set of four numbers in base ten*/
				(num)4294967279,  (num)4294967263,  (num)4294967231,  (num)4294967167,  /*  called workhorse+of+reason by daniel  */
				(num)4294967039,  (num)4294966783,  (num)4294966271,  (num)4294965247,  /*    constants of reason have names     */
				(num)4294963199,  (num)4294959103,  (num)4294950911,  (num)4294934527,  /*      ultimate answers are finite     */
				(num)4294901759,  (num)4294836223,  (num)4294705151,  (num)4294443007,  /* gods favorite number is three       */
				(num)4293918719,  (num)4292870143,  (num)4290772991,  (num)4286578687,  /*  bobs favorite number is five      */
				(num)4278190079,  (num)4261412863,  (num)4227858431,  (num)4160749567,  /*   my favorite nunber is ten       */
				(num)4026531839,  (num)3758096383,  (num)3221225471,  (num)2147483647   /* +vision is nlogn     skip is n/m */ };
num   tautologies[] = {/* spelled out */zero, one, three, seven, seven + seven + one, thirtyone, thirtyone + one + thirtyone,
/* compiled tauts in base ten */ 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535 };
const num fourthtau = tautologies[four];
const num fifthtau = tautologies[five];
const num sivthtau = tautologies[siv];
const num thetenthtau = tautologies[ten];
num minusbit(num bits, num g)
{
	when(g <= fifthtau) {
		when(bits & (one << g)) bits &= diagovreason[g];
		otherwise{ bits += (one << g); bits = minusbit(bits, g + one); }
	}
	return bits;
}
num minus(num more, num less) { for (num g = zero; g < one + fifthtau; g++) when(less & (one << g)) more = minusbit(more, g); return more; }
#define       sayvum    static      // 
#define      escLoop       break;
#define      prin        printf
#define      fprin      fprintf
typedef  void              oy;
typedef  oy                joy;         // old gold old silver old bronze
#define     yaythen        when         // highlighted ifs in template
#define     wethorse     otherwise      // highlighted else in template needing future work
#define     otemplate template          // i like otemplate better than template
otemplate < class tt > class trunk { // trunk of tree   ez is one
public://dear children constants matter cards matter theory
	oy allocay(num want)//want get theory
	{// O(const times allocay)
		num get = (one + (want + veespace)) >> one; //savor the silver bank card
		when(veespace < get) {
			tt* tmp = new tt[(num)get];
			yaythen(tmp == (tt*)zero) {
				when(get < g) { }
			} otherwise{//
				{// the idea is that memory cheds are cheap compared to problem
					num borknay = zero;
					for (num h = zero; h < get; h++)tmp[h] = (tt)zero;// +heis+
					for (num h = zero; h < get; h++) when(tmp[h] == (tt)zero) borknay++;
					yaythen(borknay == get) { } wethorse{ } }
				for (num h = zero; h < g; h++)tmp[h] = v[h];// +heis+
				for (num h = zero; h < veespace; h++)v[h] = (tt)zero;// ilovethslineverymuch
				when(v == (tt*)zero) { //doan delete a null ptr
				} otherwise{ delete[] v; }
				veespace = zero; v = tmp; veespace = get; tmp = (tt*)zero; }
		}
	}//
	trunk() :       // position zero of growth
		toe(zero),     // num note one
		eton(zero),    // num note two
		g(zero),       // how many are there
		veespace(zero),// how many could there be before growth 
		v((tt*)zero)   // one block of memory grows by fibolacci sequence  
	{ }             // jdp defense department blog using letternumerology //
	trunk(num beg) : toe(zero), eton(zero), g(zero), veespace(zero), v((tt*)zero) { when(beg) { allocay(beg); } }
	num memberp(tt elt)
	{
		for (num gee = zero; gee < g; gee++) when(v[gee] == elt) return one; return zero;
	}
	joy add(tt elt)
	{
		when(g == veespace) {
			allocay((g + (g >> one) + one));// fibolacci  grows when high is zero
			yaythen(g < veespace) { } wethorse{ return; }
		}
		v[g] = elt; g++;
	}
	inline num gee(num gee) { return gee < g; }//  	
	inline num size() { return g; }
	num setsize(num sz) { g = sz; return g; }
	inline tt& operator[](num j) { return v[j]; }
	num       toe;
	num      eton; // to count better
	num     g;
	num    veespace;
	tt* v;
	oy   clear()/* zeroes plus empties */ { for (num gee = zero; gee < veespace; gee++) v[gee] = (tt)zero; toe = zero; eton = zero; g = zero; }
	tt slop() { /*doan like word pop*/ tt ret = (tt)zero; yaythen(g) { g = lessone(g); ret = v[g]; v[g] = (tt)zero; } wethorse{ } return ret; }
	tt last() { tt ret = (tt)zero; yaythen(g) { ret = v[lessone(g)]; } wethorse{ } return ret; }
	trunk(trunk& fooool) { }//copyconstru tors are ctenoids
	~trunk() {
		for (num gee = g; gee < veespace; gee++)v[gee] = (tt)zero; /* +heis+ */ clear();
		{num borknay = zero;/*borken cheds*/ for (num gee = zero; gee < veespace; gee++) when(v[gee] == (tt)zero) borknay++; yaythen(borknay == veespace) {} wethorse{} }
		when(v == (tt*)zero) { } otherwise{ delete[] v; } veespace = zero; v = (tt*)zero;
	}
};// knurt ssalc dne
typedef trunk   < num >        nums;        //  vettor              /*type theory is all num*/
typedef trunk   < nums* >      numnums;     //  vettor of vettors   
typedef trunk   < numnums* >   numumums;  //  vettor of vettor of vettors of nums
inline num sclusiveorwayg(num way, num g)  // good for bottom siv bits only
{ // way<two is the most common
	if (way & (one << g)) { return (way & diagovreason[g]); }
	else return (way + (one << g));
}/// god bless the pope and his men
num numsize(num j) { when(j == zero) return zero; return one + numsize(j >> one); }
num lgup[] = { one, two, three, four, five, siv, seven, seven + one, seven + two, seven + three, seven + four, seven + five,
	seven + siv, seven + seven, seven + seven + one, seven + seven + two, seven + seven + three, seven + seven + four,
	seven + seven + five, seven + seven + siv, seven + seven + seven, seven + seven + seven + one, seven + seven + seven + two, seven + seven + seven + three,
	seven + seven + seven + four, seven + seven + seven + five, seven + seven + seven + siv, seven + seven + seven + seven, seven + seven + seven + seven + one,
	seven + seven + seven + seven + two, thirtyone, thirtyone + one };
num lgdown[] = { zero, zero, one, two, three, four, five, siv, seven, seven + one, seven + two, seven + three, seven + four, seven + five, seven + siv,
	seven + seven, seven + seven + one, seven + seven + two, seven + seven + three, seven + seven + four, seven + seven + five, seven + seven + siv,
	seven + seven + seven, seven + seven + seven + one, seven + seven + seven + two, seven + seven + seven + three, seven + seven + seven + four,
	seven + seven + seven + five, seven + seven + seven + siv, seven + seven + seven + seven, seven + seven + seven + seven + one, seven + seven + seven + seven + two, thirtyone };
num allones[] = { zero, one, three, seven, seven + seven + one, thirtyone, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535 };
num oneoffour[] = { zero, zero, one, zero, two, zero, one, zero, three, zero, one, zero, one, zero, one, zero };
const  num eight = four + four;
const num letterzero = '0'; const num letternine = letterzero + three + three + three; const num carriagereturn = '\n'; const num lettercee = 'c'; const num lettereff = 'f'; const num letteren = 'n'; const num letterpee = 'p';
const num letterw = 'w'; const num twiddle = '~';    const num minusletter = '-';  const num letterplus = '+'; const num lettercomma = ',';
const num spaceletter = ' ';
const num endoffileletter = (num)EOF;
typedef bool ool;               // three letter word rhymes with tool pool fool
//#define sayvum static           // seriously pedantic  doan like saying tic
////////////////////////////////////////////////////////////////////////////////
oy fprintnums(FILE* filem, nums& Nums) { num g; for (g = 0; g < Nums.size(); g++) { fprintf(filem, " %3u", Nums[g]); } fprintf(filem, "\n"); }
/////////////////////////////////////////////////////////
// goose duck and halfduck are all used for 
//  removal of negation from programs 
// 
//   plus they are useful for slowing down 
//    of programs that are too fast 
//     which has been a real issue 
//      in the new pspace result 
//       where pspace equals p 
//        for medium sizes 
// /////////////////////////////////////////////
// dum goose step bassackwards for only use the plus 
//  plus also slows down some way too fast processors 
num goose(num duck)
{ // goose steps backwards 
	num g = zero;
	num h = zero;
	num start = zero;
	for (g = start;
		g + one < duck;
		g++) {
	}
	return g;
}
num halfduck(num duck)
{ //
		// plans for half a duck 
		// similar to goose should be 
		// instead of shift bits lower by one 
	num g = zero;
	num h = zero;
	num start = zero;
	for (g = start;
		g + g + one < duck;
		g++) {
	}
	return g;
}
num dumduck(num dum, num duck)
{
	num daffy = duck;
	num g;
	for (g = zero; g < dum; g++) {
		daffy = halfduck(daffy);
	}
	return daffy;
}
num duckmud(num duck, num mud)
{
	num daffy = duck;
	num g;
	for (g = zero; g < mud; g++) {
		daffy = daffy + daffy;
	}
	return daffy;
}
num raymod(num big, num modder)
{
	num daffy = big;
	while(modder<daffy)daffy=minus(daffy, modder);      // acceptable minus to avoid possible mod zero page fault
	return daffy;
}
//
//
		//////////////////////////////////////////////
		//
		// the ray class :  a design using primes 
  //                  as a randum bit source 
		//                  with a very large cycle 
  //                  period of roughly ten to the seventy 
		// 
		// oneum numeum numbeereum 
		// oneum     :     rayndom single bits perhaps of water 
		// numeum    :    rayndom sequence of bits
		// numbereum : rayndom number, uses some numeum 
		// randomize(nums& numbers); : permute number positions 1 through n 
		//
		// the given implementation is intended 
		// to provide randum choice from a set. 
		// 
		// 
		// the primitive bit source of Prhymeum 
		//  is used for users rays choices 
		//   works very very well  
		//
		//////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
//  cost per bit analysis 
// 
//  7 cpu cycles per bit
//  the refillium averages O(1/2) cpu cycle per bit
class ray {
public:
	ray();
	ray(nums& bitsources); // for some puremint uses 
	num plus(num anum);   // enlarge set by one member
	~ray() {}             // tbd
	//
	//
	////////////////////////////////////////////
 sayvum ray Prhymeum;
	num randumprime(); //pureprhymeum++
	////////////////////////////////////////////
	//
	// there are many theorys of randum enough
	//
	// to make a gray some gray specialists
	// use randum enough sources of nums
	//
	// in the beginning  
	// seeds for differing starts
	//
	// issue should one
	// be standard
	// beginning
	//
	//
	////////////////////////////////////////////
	// 
	// precious sources  
	//  oneum  zoreum  numeum numbereum  
 //    randomize(nums& numbers); // linearly stir a list of numbers but for the dumb zero member numbered zero          
	//  more precious oneum  zoreum  numeum numbereum  
 // economy coin for children living ina megneatoh sphere of wide spread reknoun called planet earth around here   
 // 
	//
	// returns a rayndom bit
	ool    oneum();
	//
	// returns a rayndom bit
	ool    zoreum(); //  zoreum  is  rareum
	// 
	// returns a rayndom num 
	// using howmany bits of oneum
	num    numeum(num howmanybits);
	//
	// numbereum returns rayndom number less than upperbound
	//  is less than upperbound but for zero 
 //
	num    numbereum(num upperbound);
	oy randomize(nums& numbers); // linearly stir a list of numbers //
	// one member of the set
	//
	////////////////////////////////////////////
	//
	// some randum systems 
	// should be closed 
	// so they do nay 
	// pooh all over 
	// the computer
	//
	oy     closeum(); // may save final randum state someday tbd
	// final state may be useful for some systems to have such 
	//  for later restart where left off 
	//   such as testing for cycle sizes 
	//    by linear decomposition of permutation group
	//     currently in the complete set of fifteen bit primes
	//  some effort was done to make the largest cycle big 
	//   but the value of the big cycle is yet unknown
	//  
	//  to continuing to build the stargold library 
	//      from the previous final randum state 
	//       of the randum generator is 
	//        encourage but nay yet 
	//         implemented  tbd 
	//     
	////////////////////////////////////////////
	num lithium()//123
	{
		num ret;  do { ret = numbereum(ten); } while (ret == 0); return ret;//double zero through nine testing
	}
	num lithiumstream() { do { printf("%u", numbereum(ten)); } while (one); /* search for research memory foobar */}
	////////////////////////////////////////////
	//
	// set maintenance items
	//
	// chooleum is most recent choice
	// chooleum is zero when fudup
	// 
	// the whole set is 
	// in two pools
	// of nums
	//
	// i would choose to keep the primes being used to be 
	//     shorter ones than longer pseudo primes 
	//////////////////////////////////////////////////////
	nums loveums;     // two portions of pool   the unchosen 
	nums toyouhosenoses; // the chosen   together constant content  
	////////////////////////////////////////////
	////////////////////////////////////////////
	//
	//  randum counter so utility t h a t thoseare called hosenums in testing
	//  these are purely event counters 
	num booleum;	num prhymeum;	num pureprhymeum;//three ideas as strings of letters in a database used by the worlds of reason 
 //  

	////////////////////////////////////////////
	//
	//
	// thus randum bits are provided
	// by a sayvum service
	oy      refillium();
	//
//
////////////////////////////////////////////
// test whose is bigger using   betteum 
//
// is yet another attempt to get 
//  more money in my own country 
//   for primitive necessitys 
	ool betteum(char* outputin);
	num reseed() ;
};//end class ray
ray ray::Prhymeum;
num numprhymes = 3511; // the major size number for big oh analysis of Phrymeum

ray::ray()
	:
	pureprhymeum(zero),
	prhymeum(one + one),
	booleum(zero)
{
		// initial constrution of bit source 
		//  currently from set of primes 
		//   and all less than sivteen bit primes 
		//    so there is never any intentionally 
		//     long series of zeroes and ones 
		//      from any super large pseudo prime 
	for (num g = 0; g < numprhymes; g++) {
		plus(phrymes[g]); // always adds to chosenones 
		// pool construction area 
		// boo who seeks here to 
		// improve waterpower 
		// as force of 
		// nature 
	}
	// nearly end of pool construction 
} // O(numprhymes)
oy majorpause() { } // readchar to pause in a place that should be looked at 
num freadfnum(FILE* readem)
{
	nums bufnums((one << (two + two + two + two)));// initial line limit   espandable dynamically
	num charred = zero;   // subtle political comment about reading letters with teensy tiny representation
	bufnums.clear();///issues in reading ezist (peelines for just one
	for (num g = zero; ; g++) {
		charred = (num)getc(readem); bufnums.add(charred); //showme(charred);
		when(charred == zero) escLoop
			when(charred == carriagereturn) escLoop //  favorite way to escloop from getc 
			when(charred == endoffileletter) escLoop //  looks nearly similar to tautologies[thirtyone]
			when((one << (ten + ten + three + three)) < (g + one))// arb two to the twentysiv is length limit
			escLoop
	} // bufnums is lettrs of line
	num twogglum = one;
	num ispoorpoin = zero;  // num for the numbol
	for (num g = zero; g < bufnums.size(); g++) {
		when(bufnums[g] == zero) escLoop // end of one line is possible but nay recommended
			when((bufnums[g] == twiddle)  // tildy is a twwiddlum
				|| (bufnums[g] == minusletter) // for dimacs forms 
				|| (bufnums[g] == letterplus)) { // plus is a twogglum
			twogglum = one;
		} // twogglum letter was read 
		when((bufnums[g] < letterzero) || (letternine < bufnums[g])) { continue; } // continue on to numbol reader with proper twogglum  
		num by = zero;
		for (by = zero; (letterzero + by < bufnums[g]); by++) {} // counting from zero for letterzero
	 ispoorpoin = times(ten, ispoorpoin) + by;
	}
	return ispoorpoin;
}

oy  ray::closeum()
{ // huge potential here for 
// cluttering up systems 
// with information 
// about final conditions 
// for later resumption 
// of zillion year search 
// for the cycle repetition 
// 
// saving complete final state 
// of entire ray structures
// may be some specialty 
// however should 
// rather have
// a bottle
// in front
// of me 
/////FILE* ret = (FILE*)zero; fopen_s( &ret, "bobby5.log", "a+");
	FILE* dumdum = (FILE*)zero; fopen_s(&dumdum, "foolme.gob", "w");
	//pureprhymeum
	when(dumdum)fprintf(dumdum, "%12u", pureprhymeum);//thewhytrillion last number problem
 when(zero)
	for (num g = 0; g < loveums.size(); g++) {
		when(raymod(g, 10) == 0) {	fprintf(dumdum, "\n");
		}	fprintf(dumdum, " %5u,", loveums[g]);
	}	when(dumdum)	fprintf(dumdum, "\n");
	when(dumdum)fclose(dumdum);

	loveums.clear(); loveums.setsize(zero);
	toyouhosenoses.clear(); toyouhosenoses.setsize(zero);
	// 
	booleum = zero;
	prhymeum = zero;
	pureprhymeum = zero;
}

num ray::reseed() //.tzt .cpp .eze .gob 
//read the number of times to call randumprime  loveums.setsize(0); toyourchosenones.setsize(zero);
{
	FILE* filem = (FILE*)zero;
	fopen_s(&filem, "foolme.gob", "r");	//  when(filem) { when(reloadiump(filem)); }    // fclose(filem);
	num finalpureprymeumcounter = zero;
	when(filem) finalpureprymeumcounter = freadfnum(filem);	
 when(filem) fclose(filem);
 printf("p %u", finalpureprymeumcounter);
	//
//do{
/////fdothedo oneumcounter;
///	//freadf(filem, "\n");
///	////for (num g = 0; g < 3511; g++) {
///	////when(raymod(g, 10) == 0) {
///	////	//freadf(filem, "\n");
///	///}
///	//////freadf(filem, " %5u", loveums[g]);
//}while(!EOF);
	loveums.setsize(zero);
	toyouhosenoses.setsize(zero);
	for (num g = 0; g < numprhymes; g++) {
		plus(phrymes[g]); // always adds to chosenones 
		// pool construction area 
	}
	for (num g = zero; g < finalpureprymeumcounter; g++) { when((g % 100000000) == zero)printf(".");randumprime(); }
	return 0;
}
num mainbag() // 
{ // hack mainbag   for quality tests of rays 
		//  the major test is  how smooth is 
		//   the given randum distribution 
		//    over each and every element  
		//     of prime square fields   
		//  
		//  users may use the given ideas 
		//   of standard quality measure 
		//    on otherwise equal parts 
		//     upon mainly randum events 
		//      for many many purposes 
		//  
	num sum = zero;
	// 
	// constants are supposed to work 
	// when constants doan work 
	// then other foodish problems 
	// may arise 
	// due to busted bits 
	// in the arithmetic logic units 
	// or on the busses of the food business 
	// email computer systems 
	sum += (zero < one);
	sum += (zero + one);
	sum += (one + zero);
	sum += (one + one);
	sum += (zero | one);
	sum += (one | zero);
	sum += (one | one);
	sum += (one & one);
	sum += (one > zero);
	sum += (one == (one == one));
	sum += ((one == one) == one);
	sum += (one == (zero == zero));
	sum += ((zero == zero) == one);
	sum += (zero == (one == zero));
	sum += ((one == zero) == zero);
	sum += (one == (zero == zero));
	sum += ((zero == zero) == one);
	sum += (zero == (one == zero));
	sum += ((one == zero) == zero);
	sum += ((zero < zero) == zero);
	sum += ((zero + zero) == zero);
	sum += ((zero & zero) == zero);
	sum += ((zero | zero) == zero);
	sum += ((zero > zero) == zero);
	sum += ((one < zero) == zero);
	sum += ((one & zero) == zero);
	sum += ((zero > one) == zero);
	// 27 above 
	sum += ((one + one) & one) == zero;
	sum += ((one + one) & zero) == zero;
	sum += ((one & zero) & one) == zero;
	sum += ((one + zero) & zero) == zero;
	sum += ((zero & (one + one)) == zero);
	sum += ((zero + one) & zero) == zero;
	sum += ((zero + zero) & one) == zero;
	sum += ((zero + zero) & zero) == zero;
	sum += ((one + one) | one) == one + one;
	sum += ((one + one) | zero) == one + one;
	sum += ((one & zero) | one) == one;
	sum += ((one + zero) | zero) == one;
	sum += ((zero | (one + one)) == one + one);
	sum += ((zero + one) | zero) == one;
	sum += ((zero + zero) | one) == one;
	sum += ((zero + zero) | zero) == zero;
	sum += (one == (zero + one));
	sum += ((zero + one) == one);
	sum += (one == (one | one));
	sum += ((one | one) == one);
	sum += (one < (one + one));
	sum += ((one + one) > one);
	sum += ((zero > one) < (zero < one));
	sum += ((zero < one) > (zero > one));
	sum += ((one < zero) < (zero < one));
	sum += ((zero < one) > (one < zero));
	sum += ((one + one + one) == ((one + one) | one));
	// 27 + 27
	when(sum == 54) { // checks to see if compiler and cpu are reasonable 
			// on some architectures the lowest order bit or 
			// the highest order bit get fried without 
			// management knowing about the issue 
			// so always useful to begin 
			// an invaluable routine 
			// with some sanity checks 
			// 
			///////////////////////////////////////////////
			//
			// mostly these twopowers are mostly used for 
			// inside any boolum br looking on any br 
			// at any one br of the set of brs 
			// of up to eight or sivteen 
			// or formerly upto thirty two 
			// two valued bits 
			//
			///////////////////////////////////////////////////
		printf("\n the cpu appears to have   a working alu memory bus   on ones bit.");
	}
	/////////////////////////////////////////
	///// seed 1 to 11
 char fname[] = "speggy2.gob";
	when(one) { ray::Prhymeum.betteum(fname); }
	// can even print the primes in the output file 
	// although they are merely primes 
	// 
	// run this one again for 
	//  something else to do today  iamjustgoingtocleanoutmystuffandleave
	//        when(one) { Prhymeum.betteum("speggy.gob"); }
	ray::Prhymeum.closeum(); // closeum 
	return one; // delvee err when commented out hummmmmm
	return zero;
}
// 
// 
num ray::plus(num anum)
{ // when anum is zero then failure
	when(anum) { loveums.add(anum);	return anum; }
	return zero;
}
// 
ray::ray(nums& bitsources)
	:
	pureprhymeum(zero),
	prhymeum(one + one),
	booleum(zero)
{
	// 
		// initial constrution of bit source 
		//  currently from set of primes 
		//   and all less than sivteen bit primes 
		//    so there is never any intentionally 
		//     long series of zeroes and ones 
		//      from any super large pseudo prime 
	for (num g = 0; g < bitsources.size(); g++) {
		plus(bitsources[g]); // always adds to chosenones 
// pool construction area 
	}
	// nearly end of pool construction 
}
///////////////////////////////////////////////
///////////////////////////////////////////////
//
// going to begin
// asking for rands
//
// Could have little Openeum
// Could have little closeum
// Counters For Butter Smart Balance
//
// beggin is used to generate 
// a starting  place  upon the 
// randum source
//
/////////////////////////////////////////////// but this morning tiz cost per teeny tiny randum bit study
///////////////////////////////////////////////  need find that central code by one linear pass over the long forgotten code
//
///////////////////////////////////////////////
///////////////////////////////////////////////
//    the four main features of ray are these
//   numbereum   numeum   oneum zoreum   randomize 
//
num ray::randumprime() // 
{// Count how many prhymes
	pureprhymeum++;//with booleum makes the g o b
	// any any start location but quibbles with mod operation
	num start = prhymeum % loveums.size(); /// wide is never zero
	num g = (num)start;
	num zerocounter = zero;
	do {// scanning for nonzero or plucking some randum fifteenbit prime 
		when(loveums.v[g]) {	// only way out of the loop
			escLoop
		}	//  the most performed tiny area during 
		//   nearly empty pool condition is in here 
		// how many loops in here per bit iz rather smallish at ? 
		zerocounter++;
		g++; when(loveums.size() < g + one) { g = zero; }// 
		when(ten < zerocounter) { g = (start); }/*+13lines of gold code region of my writing click around your copywithme*/
		//  g returns to start before refillium
		// refillium has cost per bit less than the time of one cpu instruction
		when(g == start) refillium();
		// thanks for t h a t message 
	} while (one);
	prhymeum = loveums.v[g];
	toyouhosenoses.add(loveums.v[g]);
	loveums.v[g] = zero;
	// returns a short small source 
	// of lucky 13 bits of oneum 
	booleum = zero;
	return prhymeum;
}

oy ray::randomize(nums& numbers) /// for dumb zero anchoring /// 
{ // case 0 empty case  
	when(one < numbers.size())
		for (num p = 1; p < numbers.size(); p++) {
			num pchoose = numbereum(numbers.size());
			num tmpn = numbers.v[pchoose];  // very standard swap of two items uses a tmpn = numbers[pchoose]
			numbers.v[pchoose] = numbers.v[p]; // then sets numbers[pchoose]
			numbers.v[p] = tmpn;               // then uses tmpn into numbers[p]
		}
}// O( n*(O(numbereum)+10+7))

ool rayoneum()  // five cycles for each of twelve bits per randomprime
{
	when(ray::Prhymeum.prhymeum < (four << ++ray::Prhymeum.booleum)) 
{ ray::Prhymeum.prhymeum = ray::Prhymeum.randumprime(); ray::Prhymeum.booleum = one; }
return(((one << ray::Prhymeum.booleum) & ray::Prhymeum.prhymeum) ? one : zero);
}
num wh=20;
ool ray::oneum()  // five cycles for each of twelve bits per randomprime
{num sum=zero; for(num g=zero; g<wh; g++){sum+=rayoneum();} if (sum&1) return(sum<wh/2); return(wh/2<sum+1);}

// jdp t e n cycles of cpu per bit
ool ray::zoreum()
{// zoreum is other oneum
	return(oneum()?zero:one);
}

num ray::numeum(num howmany) //O(11*homany) instructions per numeum
{
	num sum = zero;
	for (num h = zero; h < howmany; h++) {	sum = sum + sum;	when(oneum()) sum++;	}
	return sum;
}

num ray::numbereum(num upperbound)// 5+13*log(n) cpu instructions
{num h = numsize(upperbound);
	num sum = zero; when(upperbound)
	do {	sum = numeum(h); } while (upperbound < sum + one );
	return sum; // (5+3h+(h*10))=5+13*log(n) cpu instructions
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//
// 
// as a  *****  fundamentalist  
// who actually resents abuse 
// of those two words 
// for moral reasons 
// 
// mainly interested in 
// building good oneum 
// using prhymeum 
//
// as  set theorist 
// i want random 
// to use on 
// my sets 
// 
// as conservative 
// i want the codes 
// to be conservative 
// in memputer usage plus 
// random bits should be cheap  
// plus error free  replenishable 
// prior universities include 
// purdue stanford ibm 
// gte laboratories mit 
// intel university of cincinnati
oy ray::refillium() // O(5*toyourchosenones.size()) == 5*3511 cpu instructions // or 17560 cpu instructions every 42000 bits
{// refill the fromLoveNums
	for (num g = 0; g < loveums.size(); g++) when(loveums[g]) toyouhosenoses.add(loveums[g]);	loveums.setsize(zero);
	for (num g = 0; g < toyouhosenoses.size(); g++) loveums.add(toyouhosenoses[g]);	toyouhosenoses.setsize(zero);}
///////////////////////////////////////////////
///////////////////////////////////////////////
//
// mostly from  Phrymeum
///////////////////////////////////////////////
///////////////////////////////////////////////
// finightest of randum num gen
// given a ray of nums
//
num Testum(num nplusone, num testamount, char* outputin)
{ //  test random num generator upon 
		//   random numbers less than a prime 
		//    by using a square of the prime to 
		//     record sequential events in pairs 
		//   count the events and cease when all pairs 
		//    all possible pairs have passed a threshold 
		//     then measure the quality of the distribution 
		// 
		// general observations about debugging 
		// or porting: quadratic effort needed
		// run repair fiz repair run again
		// so info structures may have
		// triangular form in code 
		// is unknown how to do
		// trianglu form
	num g, h;
	// n tells the testing distribution 
	// n also is how much effort to stir the pool 
	// to stir the bit source before start
	//  those two usages are actually independent 
	//   but they both need a number to start 
	// 
	numnums testums;
	num samePairs = 0;
	num squarePairs = 0;
	for (g = 0; g < nplusone; g++) {
		nums* last = new nums(nplusone);
		testums.add(last);
		for (h = 0; h < nplusone; h++)
			(*last).add(0);
	}
	//////////////////////////////////////////////////////////////////
	// 
	// the minimal threshold upon 
	// all the events in the test space 
	// is a fairly arbitrary nonzero number 
	//  huge huge tesh note is 
	//   when some event being searched for 
	//    never ever occurs then 
	//     is the event impossible or 
	//      are the random numbers crappy 
	// 
	num threshold = nplusone; // for small n this nlimit should be raised up 
	threshold = threshold * testamount;
	/////////////////////////////////////////////////
	num prev = zero;
	num beer = zero;
	num totalnsquared = zero;
	do {
		prev = beer;
		// when Testum was first written
		// the idea was how to use
		// Prhymeum inside radunbits
		// was many moons ago tho
		beer = ray::Prhymeum.numbereum(nplusone);
		// look for same chooleum twice in a row
		// look for same pair chooleum nums as some earlier pair 
		when(beer == prev) {
			//printf(" same twice at chooseum %u ", Prhymeum.chooseum );
			//aMinorPause(); 
		}
		(*testums[prev])[beer] ++;
		when(threshold == (*testums[prev])[beer]) {
			// one of the n squared wrapped around to zero 
			// 
			totalnsquared++;
		}
	} while (totalnsquared < (nplusone * nplusone)); // diagonals are diff 
	// have now had n squared wrap arounds 
	//  on sivteen or thirtytwo bit counters 
	//   so have a look 
	FILE* filem = NULL;
	fopen_s(&filem, outputin, "a+");  // for event details use this open  
	num sum = 0;
	for (g = 0; g < nplusone; g++) {
		// newline in the events details file 
		//  but only when nsquared is reasonably small 
		when(nplusone < 32)
			when(filem) fprintf(filem, "\n");
		for (h = 0; h < nplusone; h++) {
			sum += (*testums[g])[h];
			// adds to the sum total 
			// for detail looks in the filem 
			//  fprint the number of events 
			//   from single detailed 
			//    random possibility 
			//     which in here is 
			//      a single simple 
			//       ordered pair 
			//        from all of 
			//         them in 
			//    the prime squared field 
			//       
			when(nplusone < 32) // only print small details info 
				when(filem)	fprintf(filem, " %7u", (*testums[g])[h]);
			// so comment the above line out when 
			// the number of events to display  
			// is more than a screenful 
			// or you shall waste time 
			// waste disk space and 
			// shall learn nothing 
			//  
		}
	}
	///////////////////////////////////////////
	//
	//  get normalized quality measurements here 
	// 
	// the sum is total number of events 
	// so now to obtain measure quality 
	// to get a meaningful summary way   
	// the sum must be normalized by 
	// the features of the field  
	// which in the testing case is 
	// usually just a prime squared field 
	// 
	//  standard quality measure code fragment 
	float measure = (float)sum; // quality event measures 
	// to normalize the measure over a field 
	// the standard quality measure is by  
	// dividing by the minimal threshold 
	// on any event within the field  
	// measures are often floats
	measure /= threshold; // minimal threshold over all possible events 
	// 
	// and divide by the size of the field 
	// 
	measure /= nplusone;      // one dimension of the events 
	measure /= nplusone;      // other dimension of the events 
	//fopen( &filem, outputin, "a+");  // for big primes use this open 
	// and get rid of event details fprintfs above 
	//  ////////////////////////////////////////
	// 
	// so then  over all  sum  random tests 
	//  measure says        how well those 
	//   were distributed over all places 
	// 
	//  nearness to a constant says 
	//   very smooth distribution 
	//    independent of size n 
	// 
	when(filem)	fprintf(filem, "\nmeasure %f   of n %u    threshold %u  number random tests %u ",
		measure, lessone(nplusone), threshold, sum); // n < 256 is good testums 
	when(filem)	fclose(filem);
	for (g = 0; g < nplusone; g++) {
		delete testums[g];
		testums[g] = (nums*)zero;
	}
	return one;
}
// 
ool ray::betteum(char* outputin)
{ // seriously 
	when(zero) {
		// print zillions of years long stream of random numbers 
		// without repetition   in a sivteen bit program 
		do { printf(" %u", numbereum(10)); } while (one);	return one;	}
	// other speriments on random mod primes are easy to generate 
	num g;
	num h;
	FILE* filem = NULL;
	num primes[] = { 2, 3, 5}; ///, 11, 13, 17, 23, 29, 31 };
	for (g = 0; g < 2; g++) { // need to get up to seventeen sided dice again in pairs
		num base = primes[g];
		{ // fprintf a sample of numbereum 
			for (h = 1; h < 10000001; h = 10 * h) {
				when(base > 37 && h > 1) // only h == 1 for large base 
					continue;  // get rough est for bigger primes 
				Testum(base+1, h, outputin);
			}
			when(one) {
				fopen_s(&filem, outputin, "a+");
				//fprintf( filem, "\nc comment here  %u randum bits in base %u ", quantity, base );
				//fprintf( filem, "\nc to analyze randum bits  for quality  do thusly first " );
				//fprintf( filem, "\nc  first predit cardinality of a sequence of some length ");
				//fprintf( filem, "\nc   then count cardility of those various finite sequences ");
				when(filem)	fprintf(filem, "\n above was a standard field quality measure  over events, and heres a sticker: %u", base);
				when(filem)	fprintf(filem, "\n   pureoneum  777     wideum ");
				when(filem)	fprintf(filem, "\n   %9u        %u      %9u  \n",
					pureprhymeum, 777, loveums.size());
				when(filem)	fclose(filem);
			} // when  filem
		} // base is  done 
	} // for g many bases 
	// closeum improper here 
	return one;
}

/////////////////////////////////////////////////////
//         unsigned fifteen bits is good           //
/////////////////////////////////////////////////////
//
//541 170 63 141 
//710 82 1120 
//1374 1671 
//863 
// i had triangular form of primes as a closing polynomial of a massive file instead of one little eof letter
//

///////////////////////////////////////////
// change above to use all sivteen bit primes twas undone
// remove minusses also 
//  look at the depth of insight on that very old previous line
//   as for sivteen bit primes  well i think on that choice now
//     with a gob and prime permutation group sizing 
// perform amortized permutation to eleiminate hiccups of rand
//   was worried about smoothness in delievery of random bits 
//    and could program some crufty solution on top of perfectly good code
//
//  whenever a new elt is selected, build one elt of the 
//   subsequent permutation so when the entire bit source 
//    has been used then the new permutation of the bit source is available
//  ah yes build the subsequent pool one elt by one elt as present elts are used up 
//   good idea worth a phd or two
//
// also put the "prime square fileds" benchmark into good shape
//  improvements anyone  (i tried a little to spot the ones bias but noticed the strong bias in the last) 
//   member of the pair of prime sided dice instead esp on pair of elevens
// because some rand bit generators have huge holes in those distributions
// which makes for crappy designs in wind tunnels and in financial guesstimators
//
// hairy selldan here of randum psycho at your servitudes 

// randum graphs 
// nice to have floyd warshall for regular isomorophism id of graphs
// but can one guy do everything in a few days nay 
// so heres a random regular graph generator
//  i had a pretty good verty labelling system for graph isomorphism of regular graphs
//   the "primitive" was "just" a sorted vettor of only "distances" to all other vertys
//    number of phds  seven
/////////////////////////////////////////////////////
// three ugly theory types of computation are possibly with negation 
// used for building boolean clause structures 
// the language needs repairs there 
// and clauses in here should 
// use a twiddle symbol in 
// place of negation 
// in the nums list 
//  um ums umums 
typedef nums ums; //pairs of num qhere the evens are zero for nay twiddlum and one for twiddlum
typedef num um;
typedef numnums umums;// for cnf representation
#include <string.h>
num fprintums(FILE* filem, ums& tums)
{
	num g;
	num sum = 0;
	for (g = 0; g < tums.size(); g = g + 2) {
		sum++;
		sum++;

		//when(tums[g] == 1) // one  means print no negation symbol
		//  fprintf(filem, " ");
		when(tums[g] == 0) // zero means print the twiddle symbol 
		fprintf(filem, "+"); //
		// i really love to use plus for generated formulas here   but readers in other systems may use different single letter 
		fprintf(filem, "%u", tums[g + 1]);
		fprintf(filem, " ");
		// 0 is a dum one
		when(0 < (tums[g + 1])) sum++;
		when(9 < (tums[g + 1])) sum++;
		when(99 < (tums[g + 1])) sum++;
		when(999 < (tums[g + 1])) sum++;  // counts number of letters in base ten
	}/// doan know why the logbase ten letter counts but probably because i could
	/// the dum zero counts the number of u n n e g a t e d nums fprinted to files
	/// tums are probably good for summarys and checksum reports in stargold librarys labelled vfive and up
	/// librarian phds from abby and me for quality summarys of mass quantitys
	//printf("g")
	fprintf(filem, "0");
	return sum;
}
num printums(ums& tums)
{
	num g;
	num sum = 0;
	for (g = 0; g < tums.size(); g = g + 2) {
		sum++;
		sum++;
		printf(" "); // printums
		when(tums[g] == 1) // printums one  means print no negation symbol
			printf(" ");   // printums
		when(tums[g] == 0) // printums zero means print the negation symbol 
			printf("+");   // printums
		printf("%u", tums[g + 1]);  // printums
		// 0 is a dum one
		when(0 < (tums[g + 1])) sum++;
		when(9 < (tums[g + 1])) sum++;
		when(99 < (tums[g + 1])) sum++;
		when(999 < (tums[g + 1])) sum++;
	}
	return sum;
}
//////////////////////////////////////////////////////////////////
//
// class    class     class              shaddup
//  have we gone over the royal graphs 
//   those art a neat way to encode many graphs 
//    where the subset is huge but well specified 
//     and even has an ordering tooooooooooooooo
//   where the number of graphs may be very lerge  
//  but very true  and the sequence of graphs of 
// a set of royal graphs is something treally special 
//  where all you need is an em permutation over 
//   all the num from one to em 
//    along with an initial em list of things to permooooooooo 
// whose self chosen names of seven or less letters have the most and best anagrams of words 
//  may design implement and test royal graphs for validity then higherups will either punt or not
//
//     anyway twas an interesting day that fine royal day 
//      when yet once agayn i came up with news 
//       but nary a single professor was nay ina hurry 
//        clayming busy teaching foron youths 
//     busy busy busy    busy busy busy busy busy   twas a foron war plan imo
//      anyways  so thats what being truly royal feels like 
//       is you walk around the palace trying to find a way 
//        to tell them some things that really should be 
//         on the sacred high holy days news hour with mackneel or lying lair 
//          but everyone is too busy and they doan know who you are 
//                                                                  
//  the royal graph class is as yet undisturbed in cincinnati 
//   but the theme is a simple way to indeed clearly specify 
//    some large subset of an already clearly specified 
//     large subset of all possible graphs of size N 
//      with a permutation of size M     
//       not yet implemented or studied
// soon my ezistential banana boy soon
class royalgraph{//dream   123312132213231321
 numnums verts;// n verts by m other endpoints for size two m implied data structure
 nums totalpermutationofsizetwom;// lowerpermuptomhigherpermtotwom
 // while nezt member of verts given the permutation group
 //    gen solve formula    worthy of notes when 
};
class graph {
public:
	graph()
	{
		onecycles = 0;
		twocycles = 0;
		plusvert();  // possibly the dum zero is nay dumb
		// for fun in development i had one single active graph 
		//  plusonevert would grow that by one vert 
		//   and one might presume an inverse but i forget 
	} // add location zero to start 
	num plusvert() {
		verts.add(new nums);
		return N(); // 
	}
	num vertsplusone() { return verts.size(); }// N()+1
	num emptyedges()
	{ // remove all edges by resetting size 
			// zero the small cycle counts 
			// going to forthwith rebuild a similar graph
			// with rejiggling of tiny cycle disturbances in the planned graph
		num g;
		for (g = 0; g < verts.size(); g++)
			(*verts[g]).setsize(0);
		// teshmotes about nay using clear 
		// teshmotes about tiny quantity of rejiggling
		// teshmote about tiny changes in analysis counts of cycles
		onecycles = 0;
		twocycles = 0;
		threecycles = 0;
		return zero;
	}
	num addedge(num v1, num v2)
	{ // presently m123 counting is stimulated by adding an edge to the present graph 
			// other opportunitys   minimum spanning tree is first comes to mind   nay hamiltonian circuit
			// others  shortest distances by num edges
			//  other graph definitions i forget such as what is girth
			//   changes in status of connected components 
			//    had ancient messy connected component code of the system with bignums for counting satisfiable solutions
			//     for checking culbertson may have still the numbers that were quite large
			//      had sent in big numbers to sat conference for counting solutions to 2cnfs
			//       recommend counting number of solutions    prior to building qvariable tree as feasibility study
			//        did paper with roberto   deleted connected components code shortly after as nonuseful for the general problem
			//  the bignums package was good but it might have used minus
			//   used half the bits in whatever the word size was defined to be as the bigdigits of the bignum 
			//    printing it out was the computationally challenging but inconsequential temporally thing
			// make graph math departnebts on earth 
			//  plusonevert for universityofcincinnati 
			//   try for fifth degree graph covering america 
			//    known locals zavieruniversity is first edge 
			//     osu is second edge 
			//      case western reserve university is third edge 
			//       pennstateuniversity is fourth edge 
			//        universityofchicago is fifth and presentday final edge
			//  go for spanning tree first 
			//
		if ((v1 > zero) && (v2 > zero) && (v1 < vertsplusone()) && (v2 < vertsplusone())) {
			// graph accepts multiple edges and self loops  but...
			if (v1 < v2) {
				when((*verts[v1]).memberp(v2))twocycles++;
				(*verts[v1]).add(v2); // adds multiple edges
			}
			else if (v2 < v1) {
				when((*verts[v2]).memberp(v1))twocycles++;
				(*verts[v2]).add(v1);
			}
			else if (v1 == v2) { // adds self loops
				onecycles++;
				(*verts[v1]).add(v2);
			}
			//when v1 v2 have common v3 threecycles++
			//  common v3 == |interset v1 verts v2 verts| == #threecycles
			threecycles += interset(v1,(*verts[v2]))+interset(v2,(*verts[v1]));
		}
		return v1;
	}
	num interset(num v1, nums& v2verts) {
		num threecys = zero;
		for (num g = zero; g < v2verts.size(); g++) when(member(v1, v2verts[g]))threecys++;
		return threecys;
	}
	num member(num v1, num v3) { for (num g = zero; g < (*verts[v1]).size(); g++) { when((*verts[v1])[g] == v3) return one; } return zero; }
	num M()
	{
		num sum = 0;
		num g;
		for (g = 1; g < verts.size(); g++) {
			sum = sum + (*verts[g]).size();
		}
		return sum;
	}
	num N() {
		return goose(verts.size());
	}
	// 
	num empty() { // the inverse of plusoneverty is  emptyallvertys
		while (N() > 0) {
			delete verts.last();
			verts.slop();
		}
		return N();
	}
	~graph() { while (verts.size() > 0) { delete verts.last(); verts.slop(); } }
	// the member is a list of greater endpoints for every vert 
	// the last vert is always empty because tis an edge graph or veg
	// vert zero is always empty    dum zero
	// all others may have enpoints 
	// the number of vertys is goose(sizeplus())
	numnums verts; //royal permutation is a vettor of size M() or M()+1 perm of 1 to M
	/////////////////////
	// scratch for writing color cnfs 
	static num onecycles;
	static num twocycles;
	static num threecycles;
	static numnums vertvars; // vars of a vert 
	static umums clauses;    // clauses 
		//////////////////////////////////
	oy regularveg(num N, num D, num quantsofar); // one random regular veg into file
	num colorwithlgC(num C);
	static oy ezcolorgraph(num C, num D, num N, num quantity);
	oy copyregularveg(num copies, num C, num D, num vertices, num quantsofar); // one random regular composite veg into file
	static oy copyezcolorgraph(num copies, num C, num D, num N, num quantity);
	static FILE* colorfile;
	static num gidcounter;
	oy write()
	{
		when(colorfile == NULL)  return;
		// write some graph identifier in lieu of isomorphism 
		// need graph gen counter or random state ... 
		// what may need is better graph base for graph names
		// although the c lines and randcalls do help to identify 
		// for database organization 
		// alot better may be done with 
		// the graph isomorphism on regular graphs 
		// may be used to forever give graphs identitys that are well known 
		//  
		//  mapping  c gid  n m g    p veg n m    p cnf v e    
		//    basically two related strutures with same gid
		//      several per file have increasing gid
		// tesh point  some definitions last a long time
		// some try for compactness others clarity 
		//  usually one or the other or greatness when both 
		// warning  the file is still open 
		// for appending informulas 
		// immediately after the graph
		elementarywritegid();//c gid  n m g 
		elementarywritepveg();//  p veg n m
	}
	oy elementarywritegid()//c gid  n m g
	{
		gidcounter++; // 
		fprintf(colorfile, "\ngid %u %u %u", N(), M(), gidcounter); // 
	}
	oy elementarywritepveg()// p veg n m 
	{
		fprintf(colorfile, "\np veg %u %u\n", N(), M());//
		num g = 0;
		for (g = 1; g < verts.size(); g++) {
			fprintf(colorfile, "%u ", g);
			fprintnums(colorfile, *verts[g]);
		}
		fprintf(colorfile, "\n");
		// tesh point  some definitions last a long time
		// some try for compactness others clarity 
		//  usually one or the other or greatness when both 
		// warning  the file is still open 
		// for appending informulas 
		// immediately after the graph
	}
	//see down below elementarywritepcnf      p cnf n m 
	// dear watson of ibm   all is elementary
	static oy elementarygraph(num C, num D, num N, num quantity);

	// nonstatic
	oy elementaryveg(num N, num D, num quantsofar); // one random regular veg into file
	num elementarycolorwithC(num C);//lg C vars per verty for NlgC total vars

	static num A();// c4d9150 c4d9160 c4d9170
	static  num   B();// c4d8n64 64 files 64 forms per file
	static  num C();// c4d7n54 c4d7n55 c4d7n56 c4d7n57 c4d7n58 c4d7n59 c4d7n60 n forms per file
	static  num D();// c4d6n54 c4d6n55 c4d6n56 c4d6n57 c4d6n58 c4d6n59 c4d6n60 n forms per file
	static  num E();// c3d3n30 c3d4n30 c3d6n10 c3d6n11 c3d6n12 c3d6n13 c3d6n14 c3d6n15 c3d6n16 c3d6n17 c3d6n18 c3d6n19 c3d6n20  c3d5n180 c3d5n190 c3d5n200    
	static  num F();// c2d3n1000000 c2d4n1000000 c2d5n1000000
	static  num G();// c5d10n20 c5d10n21 c5d10n22 c5d11n55 c5d12n72
	static  num H() // fortytwo forms one per file
	{
		//c4d9150 c4d9160 c4d9170
		//c4d8n64
		//c4d7n54 c4d7n55 c4d7n56 c4d7n57 c4d7n58 c4d7n59 c4d7n60 
		//c4d6n54 c4d6n55 c4d6n56 c4d6n57 c4d6n58 c4d6n59 c4d6n60 
		//c3d3n30 c3d4n30 c3d6n10 c3d6n11 c3d6n12 c3d6n13 c3d6n14 c3d6n15 c3d6n16 c3d6n17 c3d6n18 c3d6n19 c3d6n20  c3d5n180 c3d5n190 c3d5n200    
		//c2d3n1000000 c2d4n1000000 c2d5n1000000
		//c5d10n20 c5d10n21 c5d10n22 c5d11n55 c5d12n72
		I("A", 0, 0, 0, 0); I("c4d9150", 4, 9, 150, 1); I("c4d9160", 4, 9, 160, 1); I("c4d9170", 4, 9, 170, 1);
		I("B", 0, 0, 0, 0); I("c4d8n64", 4, 8, 64, 1);
		I("C", 0, 0, 0, 0);  I("c4d7n54", 4, 7, 54, 1); I("c4d7n55", 4, 7, 55, 1); I("c4d7n56", 4, 7, 56, 1); I("c4d7n57", 4, 7, 56, 1); I("c4d7n58", 4, 7, 58, 1); I("c4d7n59", 4, 7, 59, 1); I("c4d7n60", 4, 7, 60, 1);
		I("D", 0, 0, 0, 0);  I("c4d6n54", 4, 6, 54, 1); I("c4d6n55", 4, 6, 55, 1); I("c4d6n56", 4, 6, 56, 1); I("c4d6n57", 4, 6, 57, 1); I("c4d6n58", 4, 6, 58, 1); I("c4d6n59", 4, 6, 59, 1); I("c4d6n60", 4, 6, 60, 1);
		I("E", 0, 0, 0, 0); I("c3d3n30", 3, 3, 30, 1); I("c3d4n30", 3, 4, 30, 1); I("c3d6n10", 3, 6, 10, 1); I("c3d6n11", 3, 6, 11, 1); I("c3d6n12", 3, 6, 12, 1); I("c3d6n13", 3, 6, 13, 1); I("c3d6n14", 3, 6, 14, 1); I("c3d6n15", 3, 6, 14, 1); I("c3d6n16", 3, 6, 16, 1);
		I("c3d6n17", 3, 6, 17, 1); I("c3d6n18", 3, 6, 18, 1); I("c3d6n19", 3, 6, 19, 1); I("c3d6n20", 3, 6, 20, 1);
		I("c3d5n180", 3, 5, 180, 1); I("c3d5n190", 3, 5, 190, 1); I("c3d5n200", 3, 5, 200, 1);
		I("F", 0, 0, 0, 0); I("c2d3n1000000", 2, 3, 1000000, 1); I("c2d4n1000000", 2, 4, 1000000, 1); I("c2d5n1000000", 2, 5, 1000000, 1);
		I("G", 0, 0, 0, 0);  I("c5d10n20", 5, 10, 20, 1); I("c5d10n21", 5, 10, 21, 1); I("c5d10n22", 5, 10, 22, 1); I("c5d11n55", 5, 11, 55, 1); I("c5d12n72", 5, 12, 72, 1);
	}
	static  num I(const char* fname, num C, num D, num N, num quantity)
	{
		char* file = new char[1000]; sprintf_s(file, 1000, "%s.veg", fname); FILE* filem = (FILE*)zero; fopen_s(&filem, file, "a+"); elementarygraph(C, D, N, quantity); when(filem)	fclose(filem);
	}
	static  num J()
	{
		I("A", 0, 0, 0, 0); I("c4d9n150", 4, 9, 150, 150); I("c4d9n160", 4, 9, 160, 160); I("c4d9n170", 4, 9, 170, 160);
		I("B", 0, 0, 0, 0); I("c4d8n64", 4, 8, 64, 64);
		I("C", 0, 0, 0, 0); I("c4d7n54", 4, 7, 54, 54); I("c4d7n55", 4, 7, 55, 55); I("c4d7n56", 4, 7, 56, 56); I("c4d7n57", 4, 7, 57, 57); I("c4d7n58", 4, 7, 58, 58); I("c4d7n59", 4, 7, 59, 59); I("c4d7n60", 4, 7, 60, 60);
		I("D", 0, 0, 0, 0); I("c4d6n54", 4, 6, 54, 54); I("c4d6n55", 4, 6, 55, 55); I("c4d6n56", 4, 6, 56, 56); I("c4d6n57", 4, 6, 57, 57); I("c4d6n58", 4, 6, 58, 58); I("c4d6n59", 4, 6, 59, 59); I("c4d6n60", 4, 6, 60, 60);
		I("E", 0, 0, 0, 0); I("c3d3n30", 3, 3, 30, 30); I("c3d4n30", 3, 4, 30, 30); I("c3d6n10", 3, 6, 10, 1000); I("c3d6n11", 3, 6, 11, 1000); I("c3d6n12", 3, 6, 12, 1000); I("c3d6n13", 3, 6, 13, 1000); I("c3d6n14", 3, 6, 14, 1000); I("c3d6n15", 3, 6, 14, 1000); I("c3d6n16", 3, 6, 16, 1000);
		I("c3d6n17", 3, 6, 17, 1000); I("c3d6n18", 3, 6, 18, 1000); I("c3d6n19", 3, 6, 19, 1000); I("c3d6n20", 3, 6, 20, 1000); I("c3d5n180", 3, 5, 180, 180); I("c3d5n190", 3, 5, 190, 190); I("c3d5n200", 3, 5, 200, 200);
		I("F", 0, 0, 0, 0);  I("c2d3n1000", 2, 3, 1000, 5); I("c2d4n100", 2, 4, 1000, 6); I("c2d5n1000", 2, 5, 1000, 7);
		I("G", 0, 0, 0, 0); I("c5d10n20", 5, 10, 20, 20 * 20); I("c5d10n21", 5, 10, 21, 21 * 21); I("c5d10n22", 5, 10, 22, 22 * 22); I("c5d11n55", 5, 11, 55, 55); I("c5d12n72", 5, 12, 72, 72);
	}

	static  num K()
	{
		I("A", 0, 0, 0, 0); L(3, 5, 0, 1); L(3, 5, 1, 1); L(3, 5, 2, 1); L(3, 5, 3, 1); L(3, 5, 4, 1); L(3, 5, 5, 1); L(3, 5, 6, 1); L(3, 5, 7, 1); L(3, 5, 8, 1); L(3, 5, 9, 1); L(3, 5, 10, 10); L(3, 5, 11, 10); L(3, 5, 12, 10); L(3, 5, 13, 10); L(3, 5, 14, 10); L(3, 5, 15, 10);
		L(3, 5, 16, 10); L(3, 5, 17, 10); L(3, 5, 18, 10); L(3, 5, 19, 10); L(3, 5, 20, 20); L(3, 5, 21, 21); L(3, 5, 22, 22); L(3, 5, 23, 23); L(3, 5, 24, 24); L(3, 5, 25, 25); L(3, 5, 26, 26); L(3, 5, 27, 27); L(3, 5, 28, 28); L(3, 5, 29, 29);
		L(3, 5, 30, 30);  L(3, 5, 60, 60); L(3, 5, 90, 90);  L(3, 5, 120, 120); L(3, 5, 150, 150);  L(3, 5, 180, 180);
		I("B", 0, 0, 0, 0); L(4, 9, 27, 27); L(4, 9, 36, 36); L(4, 9, 45, 45); L(4, 9, 54, 54); L(4, 9, 63, 63); L(4, 9, 72, 72); L(4, 9, 81, 81); L(4, 9, 90, 90); L(4, 9, 99, 99); L(4, 9, 108, 108); L(4, 9, 117, 117); L(4, 9, 126, 126); L(4, 9, 135, 135); L(4, 9, 144, 144);
		I("C", 0, 0, 0, 0);
		I("D", 0, 0, 0, 0);
		I("E", 0, 0, 0, 0);
		I("F", 0, 0, 0, 0);
		I("G", 0, 0, 0, 0);
	}
	static  num L(num C, num D, num N, num quantity)
	{
		char* file = new char[1000]; sprintf_s(file, 1000, "c%ud%un%u.veg", C, D, N);
		FILE* filem = (FILE*)zero; fopen_s(&filem, file, "a+"); elementarygraph(C, D, N, quantity); when(filem)	fclose(filem);
	}


	num elementarycolorwithlgC(num C);
	oy elementarymonokcnf(num k, num D, num N, num quantity);
			//num graph::finalizeoneroyalgraph(nums& topDvertys);
			// where say vum came from is well known to daniel
	static oy monokcnf(num k, num D, num N, num quantity);
	static oy nonmonokcnf(num k, num npos, num nlits, num N, num quantity);
	static oy elementaryplusgraph(num plus, num C, num D, num N, num quantity);
	oy elementaryplusveg(num plus, num vertices, num D, num quantsofar);
};

num graph::onecycles = 0;
num graph::twocycles = 0;
num graph::threecycles = 0;
num graph::gidcounter = 0;
oy graph::ezcolorgraph(num C, num D, num N, num quantity)
{
	graph::elementarygraph(C, D, N, quantity);
}
oy graph::copyezcolorgraph(num copies, num C, num D, num N, num quantity)
{
	graph gr;
	gr.copyregularveg(copies, C, D, N, quantity);
}

oy graph::elementarygraph(num C, num D, num N, num quantity)
{ // the ability to create alot of things is one thing 
		// the responsibility for managing them is quite another 
		// for brand new stuff I use quantity 1 and keep N as small as possible
		// When N is close to the degree D the instances will 
		// never be colorable with merely ( 1 + sqrt( D ) ) colors. 
		// the SCC is that for some big enough N 
		// every graph shall be so colorable. 
		// at present, my guess for "large enough" is just D*C...
		// but in theory realms that is a very small N and 
		// maybe D*D is a better guess.  we shall see,
		// and by keeping the test cases small enough
		// they may even be solvable!!! eg c4d9n100
		// c5d16nwhat is unknown
	num g;
	for (g = 0; g < quantity; g++) {
		graph gr;
		printf(" G");
		{
			////////////////////////////////
			gr.elementaryveg(N, D, quantity); // into file
			////////////////////////////////
		}
		when(C < 33) { // five high bobs limit implies 32 is colors limit 
			printf("C");
			gr.elementarycolorwithlgC(C);  //is plausible but unusual to have multiple coloring formulas for a graph here
			//gr.colorwithlgC( C + 1 );  // 
			//gr.colorwithlgC( C + 2 );   // 
			// gr.colorwithlgC( squareroot( D ) plus one )
		}
		when(C > 64 && C < 1) {
			// 64 == 2^6  6 high is bag high limitation
			// ez says handle this shit well priests or end down in hell priests
			// ez is one stuff is significantly deeper than mathematicians can presently believ
			// and their uncountable nonsense shall be illuminated by elementary students 
			// singing rhymes about childrens math that begins thusly 
			// 1*1 2*2 3*3 5*5 7*7 11*11
			// in front of math departments and cs on holy days
		}
	}
	// notes about precoloring
	// precoloring changes the number of colorings ONLY WHEN 
	// the graph is already colorable 
	// precoloring is an empirical hack 
	//  the number of possible colorings is divided by 
	//   some small number dependent upon the 
	//    size of the precoloring 
	//     SUDOKUs for ezample 
	//      have a very large precoloring 
	//       and thus are solved very fast 
	//        and with other versions of hillberg 
	//         those ran in linear time
	//      although the number of colors and degree were very large
}

oy graph::elementaryplusgraph(num plus, num C, num D, num N, num quantity)
{ // the ability to create alot of things is one thing 
		// the responsibility for managing them is quite another 
		// for brand new stuff I use quantity 1 and keep N as small as possible
		// When N is close to the degree D the instances will 
		// never be colorable with merely ( 1 + sqrt( D ) ) colors. 
		// the SCC is that for some big enough N 
		// every graph shall be so colorable. 
		// at present, my guess for "large enough" is just D*C...
		// but in theory realms that is a very small N and 
		// maybe D*D is a better guess.  we shall see,
		// and by keeping the test cases small enough
		// they may even be solvable!!! eg c4d9n100
		// c5d16nwhat is unknown
	num g;
	for (g = 0; g < quantity; g++) {
		graph gr;
		printf(" G");
		{
			////////////////////////////////
			gr.elementaryplusveg(plus, N, D, quantity); // into file
			////////////////////////////////
		}
		when(C < 33) { // five high bobs limit implies 32 is colors limit 
			printf("C");
			gr.elementarycolorwithlgC(C);  //is plausible but unusual to have multiple coloring formulas for a graph here
			//gr.colorwithlgC( C + 1 );  // 
			//gr.colorwithlgC( C + 2 );   // 
			// gr.colorwithlgC( squareroot( D ) plus one )
		}
		when(C > 64 && C < 1) {
			// 64 == 2^6  6 high is bag high limitation
			// ez says handle this shit well priests or end down in hell priests
			// ez is one stuff is significantly deeper than mathematicians can presently believ
			// and their uncountable nonsense shall be illuminated by elementary students 
			// singing rhymes about childrens math that begins thusly 
			// 1*1 2*2 3*3 5*5 7*7 11*11
			// in front of math departments and cs on holy days
		}
	}
}
oy graph::elementaryplusveg(num plus, num vertices, num D, num quantsofar)   // into file
{ ///////////////////////////////////////////////////////
	num g, h;
	nums endpoints;
	num count = 0;
	empty(); // N() vertys with size adjacents zero
	// the endpoints pool, with D copies of each verty
	for (g = 1; g < vertices + 1; g++) {
		plusvert();
		for (h = 0; h < D; h++)
			endpoints.add(g);
	}
	for (num g = 0; g < plus; g++) { //add some edges
		num r1 = ray::Prhymeum.numbereum(endpoints.size());
		num r2 = ray::Prhymeum.numbereum(endpoints.size());
		endpoints.add(endpoints[r1]); endpoints.add(endpoints[r2]);
	}
	// initial list of members to randomize;
	num randcalls = 0;
	nums ptrs;
	for (g = 0; g < endpoints.size(); g++)
		ptrs.add(g);
	nums minsofar; // best set of endpoints so far by some measure of quantitys of small cycles
	num msfthreecycles = vertices * vertices * vertices; // must start as sufficiently large number
	num msftwocycles = zero;
	num msfonecycles = zero;
	do {
		// randomize a subset of the endpoints pool 
		for (g = 0; g < ptrs.size(); g++) {
			num elt = endpoints[ptrs[g]];
			num r = ray::Prhymeum.numbereum(endpoints.size());
			randcalls++;
			endpoints[ptrs[g]] = endpoints[r];
			endpoints[r] = elt;
		}
		// ptrs now empty 
		ptrs.setsize(zero);
		// 1 cycles get randomized again
		// 2 cycles get randomized again
		// threecycles get randomized again
		// graph is empty of edges 
		emptyedges();
		when(D && ((count + 1) % (D)) == zero && minsofar.size() == endpoints.size()) {
			//     revert to minsofar
			endpoints.clear();
			for (num g = zero; g + one < minsofar.size(); g = g + two) {
				endpoints.add(minsofar[g]);
				endpoints.add(minsofar[g + 1]);
			}
		}
		for (g = 0; g + 1 < endpoints.size(); g = g + 2) {
			num before = onecycles + twocycles + threecycles;
			addedge(endpoints[g], endpoints[g + 1]);
			//                + threecycles
			when(zero && onecycles + twocycles + threecycles > before) {
				ptrs.add(g); // randomize one of the ornry endpoints 
				// ptrs.add( g+1 );  randomizing both would eventually succeed
				//... But.///as i recall i was proud and stingy with usage of my genrandombit routine where a bit costs 7 cpu cycles
				ptrs.add(g + 1);//at least try it
			}
		}
		when(threecycles < msfthreecycles || (threecycles == msfthreecycles && twocycles < msftwocycles) || (threecycles == msfthreecycles && twocycles == msftwocycles && onecycles == onecycles)) {
			minsofar.clear();
			// nice to repair onecycles before saving to minsofar   future work
			// two cycles are naysobad  O(D) of them
			for (num g = zero; g + 1 < endpoints.size(); g = g + two) {
				minsofar.add(endpoints[g]); minsofar.add(endpoints[g + 1]);
			}
			msfthreecycles = threecycles;  msfonecycles = onecycles;   msftwocycles = twocycles;
		}
		//  quit basically after dfourth plus dcubed plus dsquared 
		//fprintf(colorfile, "\nc N %u D %u M %u   ones %u twos %u threes %u",
		//  N(), D, M(), onecycles, twocycles, threecycles);
		//
		// the situation 
		//  desire zero one cycles for sure, mostly.  
		//   would also like very few twocycles, when possible.
		// threecycles agenda is perhaps useful for five coloring   yet to be determined
		// 
		// BUT ALSO limit on number of Tries 
		//   for removing 1 and 2 cycles 
		// logD was supposedly all we need but 
		//  but, cleanup must fail when  N < D, 
		// so need the terminator here 
		count++;///////////////ezizzopleazed
		//
		// tried several times more than we needed for success, so... 
		//   the little impurity That rerandomization is trying to avaoid is
		//    multiple edges avoid if possible and self loops avoid if possible 
		//     so 1cycles and 2cycles get identified as they crop up 
		//      for later rerandom one of the endpoints 
		//       the thing is when N == D, it ain possible,
		//        and when N = D+1, there is only one solution 
		//         which would be found eventually 
		//          at random    
		//     Sooooo what is that spetted number then 
		//      am boosting the guess of limits on 
		//       solving this through random 
		//        twould become a good study 
		//         in and of itself 
		//          with the result 
		//           being worthy  
		//            of prints 
		//          upon papyrus 
		// 
		//  while this generator wath created 
		//   D wath much smaller than N 
		//    after though the code 
		//     may become carved 
		//      in stone and so 
		//  good test case makers are 
		//   sometimes more valuable 
		//    than the case solvers 
		//     so some effort 
		//      neatly please 
		//       would be nice 
		////////////////////////////////////////////////////////////////////////
		//
		// primarily removal of one cycles is the desire 
		//  also trying to remove two cycles too 
		//   with same rerandomization theme 
		//
		// now as these things become math library routines
		//  for papers about graphs 
		//   with less scuses about multigraphs 
		//    there will be large cases for D 
		//     where N is small   and Then 
		//      properly asked what propertys there 
		//       where one cycles are yet still trimmed 
		//        when plausible 
		//         tis almost an inverse coloring problem then 
		//        where N is the number of colors 
		//       each never one cycled 
		//      too many notes says the king unto mozart
		//     and thus mozart must bow to the king and say 
		//    i agree royal sir  
		//   too many instruments too many notes 
		//  so the claim for this design 
		// is tis well for N >= D 
		//
		when((count > D * D + D * D + D * D * D + D * D + D))//O(D*D)
			escLoop
	} while ((ptrs.size() > zero) && (count < one + D * D * D));//O(D to the third)
	// minsofar msfonecycles msftwocycles msfthreecycles
		{
			emptyedges();
			endpoints.clear(); for (num g = zero; g < minsofar.size(); g++) endpoints.add(minsofar[g]);
			threecycles = msfthreecycles;  onecycles = msfonecycles;    twocycles = msftwocycles;
			//install minsofar  reduce onecycles
			for (g = 0; g + 1 < endpoints.size(); g = g + 2) {
				num before = onecycles;
				addedge(endpoints[g], endpoints[g + 1]);
				when(onecycles > before) {
					ptrs.add(g); // randomize one of the ornry endpoints 
				}
			}
			when(ptrs.size()) { //onecycles
					// randomize a subset of the endpoints pool 
				for (g = 0; g < ptrs.size(); g++) {
					num elt = endpoints[ptrs[g]];
					num r = ray::Prhymeum.numbereum(endpoints.size());
					randcalls++;
					endpoints[ptrs[g]] = endpoints[r];
					endpoints[r] = elt;
				}
				// ptrs now empty 
				ptrs.setsize(zero);
				// 1 cycles got randomized again  hopefully gone 
				emptyedges();
				for (g = 0; g + 1 < endpoints.size(); g = g + 2) {
					num before = onecycles;
					addedge(endpoints[g], endpoints[g + 1]);
					when(onecycles > before) {
						ptrs.add(g); // randomize one of the ornry endpoints 
					}
				}
				// when ptrs.size() colorable isnay
			}
		}
		when(0) { // write the graph
				// count is higher relatively when N is lower nearer to D 
				// similarly for randcalls 
				// as N gets large the difficultys in creation go lower 
			fprintf(colorfile, "\nc N%u D%u M%u reps %u randcalls %u", N(), D, M(), count, randcalls);
			fprintf(colorfile, "   ones %u twos %u threes %u", onecycles, twocycles, threecycles);
			write();
			// append graph to file
			// write formula soon
		}
}
oy graph::elementaryveg(num vertices, num D, num quantsofar)   // into file
{ ///////////////////////////////////////////////////////
	num g, h;
	nums endpoints;
	num count = 0;
	empty(); // N() vertys with size adjacents zero
	// the endpoints pool, with D copies of each verty
	for (g = 1; g < vertices + 1; g++) {
		plusvert();
		for (h = 0; h < D; h++)
			endpoints.add(g);
	}
	// initial list of members to randomize;
	num randcalls = 0;
	nums ptrs;
	for (g = 0; g < endpoints.size(); g++)
		ptrs.add(g);
	nums minsofar; // best set of endpoints so far by some measure of quantitys of small cycles
	num msfthreecycles = vertices * vertices * vertices; // must start as sufficiently large number
	num msftwocycles = zero;
	num msfonecycles = zero;
	do {
		// randomize a subset of the endpoints pool 
		for (g = 0; g < ptrs.size(); g++) {
			num elt = endpoints[ptrs[g]];
			num r = ray::Prhymeum.numbereum(endpoints.size());
			randcalls++;
			endpoints[ptrs[g]] = endpoints[r];
			endpoints[r] = elt;
		}
		// ptrs now empty 
		ptrs.setsize(zero);
		// 1 cycles get randomized again
		// 2 cycles get randomized again
		// threecycles get randomized again
		// graph is empty of edges 
		emptyedges();
		when(D && ((count + 1) % (D)) == zero && minsofar.size() == endpoints.size()) {
			//     revert to minsofar
			endpoints.clear();
			for (num g = zero; g + one < minsofar.size(); g = g + two) {
				endpoints.add(minsofar[g]);
				endpoints.add(minsofar[g + 1]);
			}
		}
		for (g = 0; g + 1 < endpoints.size(); g = g + 2) {
			num before = onecycles + twocycles + threecycles;
			addedge(endpoints[g], endpoints[g + 1]);
			//                + threecycles
			when(zero && onecycles + twocycles + threecycles > before) {
				ptrs.add(g); // randomize one of the ornry endpoints 
				// ptrs.add( g+1 );  randomizing both would eventually succeed
				//... But.///as i recall i was proud and stingy with usage of my genrandombit routine where a bit costs 7 cpu cycles
				ptrs.add(g + 1);//at least try it
			}
		}
		when(threecycles < msfthreecycles || (threecycles == msfthreecycles && twocycles < msftwocycles) || (threecycles == msfthreecycles && twocycles == msftwocycles && onecycles == onecycles)) {
			minsofar.clear();
			// nice to repair onecycles before saving to minsofar   future work
			// two cycles are naysobad  O(D) of them
			for (num g = zero; g + 1 < endpoints.size(); g = g + two) {
				minsofar.add(endpoints[g]); minsofar.add(endpoints[g + 1]);
			}
			msfthreecycles = threecycles;  msfonecycles = onecycles;   msftwocycles = twocycles;
		}
		//  quit basically after dfourth plus dcubed plus dsquared 
		//fprintf(colorfile, "\nc N %u D %u M %u   ones %u twos %u threes %u",
		//  N(), D, M(), onecycles, twocycles, threecycles);
		//
		// the situation 
		//  desire zero one cycles for sure, mostly.  
		//   would also like very few twocycles, when possible.
		// threecycles agenda is perhaps useful for five coloring   yet to be determined
		// 
		// BUT ALSO limit on number of Tries 
		//   for removing 1 and 2 cycles 
		// logD was supposedly all we need but 
		//  but, cleanup must fail when  N < D, 
		// so need the terminator here 
		count++;///////////////ezizzopleazed
		//
		// tried several times more than we needed for success, so... 
		//   the little impurity That rerandomization is trying to avaoid is
		//    multiple edges avoid if possible and self loops avoid if possible 
		//     so 1cycles and 2cycles get identified as they crop up 
		//      for later rerandom one of the endpoints 
		//       the thing is when N == D, it ain possible,
		//        and when N = D+1, there is only one solution 
		//         which would be found eventually 
		//          at random    
		//     Sooooo what is that spetted number then 
		//      am boosting the guess of limits on 
		//       solving this through random 
		//        twould become a good study 
		//         in and of itself 
		//          with the result 
		//           being worthy  
		//            of prints 
		//          upon papyrus 
		// 
		//  while this generator wath created 
		//   D wath much smaller than N 
		//    after though the code 
		//     may become carved 
		//      in stone and so 
		//  good test case makers are 
		//   sometimes more valuable 
		//    than the case solvers 
		//     so some effort 
		//      neatly please 
		//       would be nice 
		////////////////////////////////////////////////////////////////////////
		//
		// primarily removal of one cycles is the desire 
		//  also trying to remove two cycles too 
		//   with same rerandomization theme 
		//
		// now as these things become math library routines
		//  for papers about graphs 
		//   with less scuses about multigraphs 
		//    there will be large cases for D 
		//     where N is small   and Then 
		//      properly asked what propertys there 
		//       where one cycles are yet still trimmed 
		//        when plausible 
		//         tis almost an inverse coloring problem then 
		//        where N is the number of colors 
		//       each never one cycled 
		//      too many notes says the king unto mozart
		//     and thus mozart must bow to the king and say 
		//    i agree royal sir  
		//   too many instruments too many notes 
		//  so the claim for this design 
		// is tis well for N >= D 
		//
		when((count > D * D + D * D + D * D * D + D * D + D))//O(D*D)
			escLoop
	} while ((ptrs.size() > zero) && (count < one + D * D * D));//O(D to the third)
	// minsofar msfonecycles msftwocycles msfthreecycles
		{
			emptyedges();
			endpoints.clear(); for (num g = zero; g < minsofar.size(); g++) endpoints.add(minsofar[g]);
			threecycles = msfthreecycles;  onecycles = msfonecycles;    twocycles = msftwocycles;
			//install minsofar  reduce onecycles
			for (g = 0; g + 1 < endpoints.size(); g = g + 2) {
				num before = onecycles;
				addedge(endpoints[g], endpoints[g + 1]);
				when(onecycles > before) {
					ptrs.add(g); // randomize one of the ornry endpoints 
				}
			}
			when(ptrs.size()) { //onecycles
					// randomize a subset of the endpoints pool 
				for (g = 0; g < ptrs.size(); g++) {
					num elt = endpoints[ptrs[g]];
					num r = ray::Prhymeum.numbereum(endpoints.size());
					randcalls++;
					endpoints[ptrs[g]] = endpoints[r];
					endpoints[r] = elt;
				}
				// ptrs now empty 
				ptrs.setsize(zero);
				// 1 cycles got randomized again  hopefully gone 
				emptyedges();
				for (g = 0; g + 1 < endpoints.size(); g = g + 2) {
					num before = onecycles;
					addedge(endpoints[g], endpoints[g + 1]);
					when(onecycles > before) {
						ptrs.add(g); // randomize one of the ornry endpoints 
					}
				}
				// when ptrs.size() colorable isnay
			}
		}
		when(0) { // write the graph
				// count is higher relatively when N is lower nearer to D 
				// similarly for randcalls 
				// as N gets large the difficultys in creation go lower 
			fprintf(colorfile, "\nc N%u D%u M%u reps %u randcalls %u", N(), D, M(), count, randcalls);
			fprintf(colorfile, "   ones %u twos %u threes %u", onecycles, twocycles, threecycles);
			write();
			// append graph to file
			// write formula soon
		}
}
num graph::elementarycolorwithlgC(num C) // color with C colors, lgC vars per vert 
{
	// when C is one    
	//  then one var for every verty 
	//    same as when C is two 
	//     but only zero degree 
	//      shall work out well
	// 
	num g, g2, h, c;
	num lgC = 0;
	while (C > (one << lgC)) // issue about zero 
		lgC++;
	when(lgC == zero) {
		// should yay be one var per verty 
		//  and one clause too saying
		//   only one color so
		//    when C is one 
		lgC = C;
	}
	// builds a pone to color the graph with C colors
	// the number of variables for each vert is lgC 
	// the size of the clauses is usually 2lgC
	// prediction of hardest 6cnf problems: 
	// degree D is 49, with 8 colors, N > 400.
	// possibly N > D*D for asymptotics, but
	// I have used N = D*C successfully for D <= 20
	// for successful 6 and 5 colorings
	//
	numnums vertvars;
	vertvars.setsize(0);
	when(vertvars.size() == 0) {
		vertvars.add(new nums); // zero dum one 
	}
	for (g = 0; g < N(); g++) { // counting begins at none 
		vertvars.add(new nums);
		// add lgC vars to vert 
		//  numbering system is 
		//   is (G+1) + h*N(), for h < lgC, 
		//    for each vert G of the graph 
		for (h = 0; h < lgC; h++) { // variable numbering art form 
				// am trying new art form 
				// to make identity of ezistential variables
				// easier to comprehend 
				// they tend to be higher numbered  (N+1,.., lgC*N).
				// while the universals tend to be lower numbered (1..N)
				// thus the new numbering method which 
				//  is not necessary, strictly speaking. 
			(*vertvars[g + 1]).add(g + 1 + h * N()); // variables begin at one 
		}
	}
	printf("v");
	// use only colors from zero almost upto C 
	// zero out higher color numbers 
	for (g = 1; g <= N(); g++) {
		for (c = C; c < (one << lgC); c++) {
			ums* cl = new ums();
			// verts[ g ] is not c 
			for (h = 0; h < lgC; h++) {
				if (((one << h) & c) == 0) { // bit h of c  is OFF? 
					(*cl).add(1); // +
					(*cl).add(((*vertvars[g])[h]));    // bit h og g  is ON   
				}
				else {
					(*cl).add(0); // 
					(*cl).add(((*vertvars[g])[h]));
				}
			}
			clauses.add(cl);
		}
	}
	printf("N");
	// when using precoloring for simple speedup 
	// the suggestion is to find a triangle 
	printf("T");
	// 
	///////////////////////////////////////////////
	// colors from zero to lessone(C) are the colors
	// any encoding of a color beyond there
	// becomes the negation of a clause
	// 
	for (g = 1; g <= N(); g++) {
		num v1 = g;
		for (g2 = 0; g2 < (*verts[g]).size(); g2++) {
			num v2 = (*verts[g])[g2];
			when(v1 == v2)
				continue; // doan color self loops

			for (c = 0; c < C; c++) {
				ums* cl = new ums;
				// v1 is not c 
				// OR 
				// v2 is not c 
				// verts[ v1 ] is not c 
				for (h = 0; h < lgC; h++) {
					if (((one << h) & c) == 0) { // bit h of c  is OFF? 
						(*cl).add(1); // +
						(*cl).add(((*vertvars[v1])[h]));    // bit h og g  is ON 
					}
					else {
						(*cl).add(0); // 
						(*cl).add(((*vertvars[v1])[h]));
					}
				}
				// OR 
				// verts[ v2 ] is not c 
				// verts[ v2 ] is not c 
				for (h = 0; h < lgC; h++) {
					if (((one << h) & c) == 0) { // bit h of c  is OFF? 
						(*cl).add(1); // +
						(*cl).add(((*vertvars[v2])[h]));    // bit h og g  is ON 
					}
					else {
						(*cl).add(0); // 
						(*cl).add(((*vertvars[v2])[h]));
					}
				}
				//printf("\n"); printums(*cl); // debug 
				clauses.add(cl);
			}
		}
	}
	//elementarywritepcnf
	fprintf(colorfile, "\np cnf %u %u", lgC* N(), clauses.size()); // d
	for (g = 0; g < clauses.size(); g++) {
		fprintf(colorfile, "\n");
		fprintums(colorfile, *clauses[g]);
	}
	fprintf(colorfile, "\n");	fprintf(colorfile, "\n");
	printf("W");
	for (g = 0; g < clauses.size(); g++) {
		delete clauses[g];
		clauses[g] = NULL;
	}
	clauses.setsize(0);
	printf("D");
	for (g = 0; g < vertvars.size(); g++) {
		delete vertvars[g];
		vertvars[g] = NULL;	}
	vertvars.setsize(0);
	printf(" graph    p veg v e    informula    p one v c    printed into file ");
	return 1;
}
oy graph::copyregularveg(num copies, num C, num D, num vertices, num quantsofar)   // into file
{ ///////////////////////////////////////////////////////
		//
		//  the royal graph representation 
		//   where just one initial set 
		//    of two em endpoints 
		//     arrayed in initial order 
		//      paired with a permutation of 1 thru two em 
		//       yields many many random graphs 
		//        with few very large files 
		//   plus all the graphs of a royal graph 
		//    are accessible as permutation group members 
		//     over one thru two em    upon the initial set of endpoints 
		//      to maintain graph librarys is an arduous tedious affair 
		//       with so  many possible graphs 
		//        anyway tis an idea 
		//         for subgroups of graphs 
		//          that belong in 
		//           a big coloring book 
		// the answer is simply nay   royal graphs of p vegs are unsupported 
		//  jdp agrees with god    the idea of n factorial versions of an initial graph 
		//   is espressible   but   N factorial is computable but as N gets bigger and bigger 
		//  computers sometimes end in aytch eee double toothpicks
		//////////////////////////////////////////////////////
		//
		//      ...read the current state of neverending rand 
		//      ...from the well known rand state file
		//      
		//      somehow i want to encourage some saving of randomstate of a randombit generator 
		//      i would think perhaps every state capitol should have one 
		//      and when the parliaments want to vote 
		//      their random bit generator should be queried 
		//      for members how to vote perhaps 
		//      because the slight bias towards one for the votes 
		//      profuces good results in the long term
		//
		//      universitys should have such
		//      
	num g, h;
	nums endpoints;
	num count = 0;
	empty(); // N() vertys with size adjacents zero
	// the endpoints pool with D copies of each verty
	for (g = 1; g < vertices + 1; g++) {
		plusvert();
		for (h = 0; h < D; h++)
			endpoints.add(g);
	}
	//for irregular graphs
	//for (g = 1; g < 34 + 1 && g < vertices + 1; g++) {
	//     endpoints.add(g);
	//} 
	//for (g = 1; g < 4 + 1 && g < vertices + 1; g++) {
	//     endpoints.add(g);
	//}
	//for (g = 1; g < 2 + 1 && g < vertices + 1; g++) {
	//     endpoints.add(g);
	//}
	// could just randomize once BUT
	//  then there are O(D) 1 cycles and O(D) 2 cycles
	//   Then the papers need to make escuses about multigraphs
	//  so randomize several times reducing the number of 
	//   1 and 2 cycles each time  needs logD total repetitions
	//  and the total number of calls to random member 
	//   is N + O(D logD)
	//
	//  O(D to the k) k cycles 
	//   as N goes to infinity and beyond 
	//    when n is small the number of k cycles is larger key
	//                                                              
	//        
	// initial list of members to randomize
	num randcalls = 0;
	nums ptrs;
	for (g = 0; g < endpoints.size(); g++)
		ptrs.add(g);
	nums minsofar; // best set of endpoints so far by some measure of quantitys of small cycles
	num msfthreecycles = vertices * vertices * vertices; // must start as sufficiently large number
	num msftwocycles = zero;
	num msfonecycles = zero;
	do {
		// randomize a subset of the endpoints pool 
		for (g = 0; g < ptrs.size(); g++) {
			num elt = endpoints[ptrs[g]];
			num r = ray::Prhymeum.numbereum(endpoints.size());
			randcalls++;
			endpoints[ptrs[g]] = endpoints[r];
			endpoints[r] = elt;
		}
		// ptrs now empty 
		ptrs.setsize(zero);
		// 1 cycles get randomized again
		// 2 cycles get randomized again
		// threecycles get randomized again
		emptyedges();
		when(D && ((count + 1) % (D)) == zero && minsofar.size() == endpoints.size()) {
			//     revert to minsofar
			endpoints.clear();
			for (num g = zero; g + one < minsofar.size(); g = g + two) {
				endpoints.add(minsofar[g]);
				endpoints.add(minsofar[g + 1]);
			}
		}
		for (g = 0; g + 1 < endpoints.size(); g = g + 2) {
			num before = onecycles + twocycles + threecycles;
			addedge(endpoints[g], endpoints[g + 1]);
			//                + threecycles
			when(zero && onecycles + twocycles + threecycles > before) {
				ptrs.add(g); // randomize one of the ornry endpoints 
				// ptrs.add( g+1 );  randomizing both would eventually succeed
				//proud and stingy with usage of genrandombit routine where a bit costs 7 cpu cycles
				ptrs.add(g + 1);//at least try it
			}
		}
		when(threecycles < msfthreecycles) {
			minsofar.clear();
			// nice to repair onecycles before saving to minsofar   future work
			// two cycles are naysobad  O(D) of them
			for (num g = zero; g + 1 < endpoints.size(); g = g + two) {
				minsofar.add(endpoints[g]); minsofar.add(endpoints[g + 1]);
			}
			msfthreecycles = threecycles;  msfonecycles = onecycles;   msftwocycles = twocycles;
		}
		//  quit basically after dfourth plus dcubed plus dsquared 
		fprintf(colorfile, "\nc N %u D %u M %u   ones %u twos %u threes %u",
			N(), D, M(), onecycles, twocycles, threecycles);
		//
		// the situation 
		//  desire zero one cycles for sure mostly
		//   would also like very few twocycles when possible
		// threecycles agenda is perhaps useful for five coloring   yet to be determined
		// 
		// BUT ALSO limit on number of Tries 
		//   for removing 1 and 2 cycles 
		// logD was supposedly all we need but 
		//  but cleanup must fail when  N < D
		// so need the terminator here 
		count++;///////////////ezizzopleazed
		//
		// tried several times more than we needed for success, so... 
		//   the little impurity That rerandomization is trying to avaoid is
		//    multiple edges avoid if possible and self loops avoid if possible 
		//     so 1cycles and 2cycles get identified as they crop up 
		//      for later rerandom one of the endpoints 
		//       the thing is when N == D it ain possible
		//        and when N = D+1 there is only one solution 
		//         which would be found eventually 
		//          at random    possibly neat
		//     Sooooo what is that spetted number then 
		//      am boosting the guess of limits on 
		//       solving this through random 
		//        twould become a good study 
		//         in and of itself 
		//          with the result 
		//           being worthy  
		//            of prints 
		//          upon papyrus 
		// 
		//  while this generator wath created 
		//   D wath much smaller than N 
		//    after though the code 
		//     may become carved 
		//      in stone and so 
		//  good test case makers are 
		//   sometimes more valuable 
		//    than the case solvers 
		//     so some effort 
		//      neatly please 
		//       would be nice but who has the time
		////////////////////////////////////////////////////////////////////////
		//
		// primarily removal of one cycles is the desire.
		//  also trying to remove two cycles too 
		//   with same rerandomization theme 
		//
		// now as these things become math library routines
		//  for papers about graphs 
		//   with less scuses about multigraphs 
		//    there will be large cases for D 
		//     where N is small   and Then 
		//      properly asked what propertys there 
		//       where one cycles are yet still trimmed 
		//        when plausible 
		//         tis almost an inverse coloring problem then.
		//        where N is the number of colors 
		//       each never one cycled 
		//      too many notes says the king unto mozart
		//     and thus mozart must bow to the king and say 
		//    i agree royal sir  
		//   too many instruments too many notes 
		//  so the claim for this design 
		// is tis well for N >= D 
		//
		when((count > D * D + D * D + D + D))//O(D*D)
			escLoop
	} while ((ptrs.size() > zero) && (count < one + D * D * D));//O(D to the third)
	// minsofar msfonecycles msftwocycles msfthreecycles
		{
			emptyedges();
			endpoints.clear(); for (num g = zero; g < minsofar.size(); g++) endpoints.add(minsofar[g]);
			//threecycles = msfthreecycles;  onecycles = msfonecycles ;    twocycles = msftwocycles 
			//install minsofar  reduce onecycles
			for (g = 0; g + 1 < endpoints.size(); g = g + 2) {
				num before = onecycles;
				addedge(endpoints[g], endpoints[g + 1]);
				when(onecycles > before) {
					ptrs.add(g); // randomize one of the ornry endpoints 
				}
			}
			when(ptrs.size()) { //onecycles
					// randomize a subset of the endpoints pool 
				for (g = 0; g < ptrs.size(); g++) {
					num elt = endpoints[ptrs[g]];
					num r = ray::Prhymeum.numbereum(endpoints.size());
					randcalls++;
					endpoints[ptrs[g]] = endpoints[r];
					endpoints[r] = elt;
				}
				// ptrs now empty 
				ptrs.setsize(zero);
				// 1 cycles got randomized again  hopefully gone but ifnay the graph is just flawed and nay colorable
				emptyedges();
				for (g = 0; g + 1 < endpoints.size(); g = g + 2) {
					num before = onecycles;
					addedge(endpoints[g], endpoints[g + 1]);
					when(onecycles > before) {
						ptrs.add(g); // randomize one of the ornry endpoints 
					}
				}
				// when ptrs.size() colorable isnay
			}
			// gordo isnay
		}
		//copies
		for (num cc = zero; cc < copies; cc++) {
			num bign = N();
			for (num j = 1; j <= bign; j++) {
				plusvert();
			}
			for (num j = 1; j <= bign; j++) {
				num v = bign + j;
				//verts[v]
				for (num k = zero; k < (*verts[j]).size(); k++) {
					(*verts[v]).add((*verts[j])[k] + bign);
				}
			}
		}
		when(1) { // write the graph
			char* comment = new char[1000];
			// count is higher relatively when N is lower nearer to D 
			// similarly for randcalls 
			// as N gets large the difficultys in creation go lower 
			//sprintf(comment, "\nc N%u D%u M%u reps %u randcalls %u", N(), D, M(), count, randcalls)
			write();
			// append graph to file
			// append formula soon
		}
}

// gen boolean p one n m for C coloring some graph
// keep graph ID in header of pone is nice but not always done
// generally i want to keep 
// the graph first in the file
// the C coloring translation to pone second
//  any solution to the pone in the log
//
// as much in one file as feasible.
// because these become unuseabe when in multiple files
// for debugging separate files
//  but i have found the muliple files related to same instance
//   causes alot of later thrashing and trashing
//


oy graph::monokcnf(num k, num D, num N, num quantity)
{ // the ability to create alot of things is one thing 
		// the responsibility for managing them is quite another 
	num g;
	for (num gg = 0; gg < quantity; gg++) {
		printf(" M");
		{
			////////////////////////////////
			num h;
			nums endpoints;
			for (g = 1; g < N + 1; g++) {
				for (h = 0; h < D; h++)
					endpoints.add(g);
			}
			// could just randomize once; BUT
			//  then there are O(D) 1 cycles and O(D) 2 cycles
			//   Then, the papers need to make escuses about multigraphs
			//  so, randomize several times, reducing the number of 
			//   1 and 2 cycles each time.  needs logD total repetitions
			//  and the total number of calls to random member 
			//   is N + O(D logD)
			//
			//  O(D to the k) k cycles perhaps O(D^(k less 1) (k choose two))
			//   as N goes to infinity and beyond 
			//    when n is small the number of k cycles is larger
			//                                                              
			//        
			// initial list of members to randomize
			num randcalls = 0;
			// randomize a subset of the endpoints pool 
			for (g = 0; g < endpoints.size(); g++) {
				num elt = endpoints[g];
				num r = ray::Prhymeum.numbereum(endpoints.size());
				randcalls++;
				endpoints[g] = endpoints[r];
				endpoints[r] = elt;
			}
			for (g = 0; g + k < endpoints.size(); g++) {
				ums* cl = new ums;
				for (num c = 0; c < k; c++) {
					(*cl).add(1); // +
					(*cl).add(endpoints[g + c]);
				}
				clauses.add(cl);
			}

			printf("F");
			fprintf(colorfile, "\nc Monotone k %u D %u reg N %u cnf ", k, D, N);
			fprintf(colorfile, "\np cnf %u %u", N, clauses.size()); // 
			for (g = 0; g < clauses.size(); g++) {
				fprintf(colorfile, "\n");
				fprintums(colorfile, *clauses[g]);
			}
			fprintf(colorfile, "\n");
			fprintf(colorfile, "\n");
			printf("W");
			for (g = 0; g < clauses.size(); g++) {
				delete clauses[g];
				clauses[g] = NULL;
			}
			clauses.setsize(0);
			printf("D");
			////////////////////////////////
		}
	}
}

oy graph::elementarymonokcnf(num k, num D, num N, num quantity)
{ // the ability to create alot of things is one thing 
		// the responsibility for managing them is quite another 
		// for brand new stuff I use quantity 1 and keep N as small as possible
		// When N is close to the degree D the instances will 
		// never be colorable with merely ( 1 + sqrt( D ) ) colors
		// the strong coloring coloring is that for some big enough N 
		// every graph shall be so colorable
		// at present, my guess for "large enough" is just D*C...
		// but in theory realms that is a very small N and 
		// maybe D*D is a better guess.  we shall see
		// and by keeping the test cases small enough
		// they may even be solvable!!!
		// 
	num g;
	for (num gg = 0; gg < quantity; gg++) {
		printf(" M");
		{
			////////////////////////////////
			num h;
			nums endpoints;
			for (g = 1; g < N + 1; g++) {
				for (h = 0; h < D; h++)
					endpoints.add(g);
			}
			// could just randomize once; BUT
			//  then there are O(D) 1 cycles and O(D) 2 cycles
			//   Then, the papers need to make escuses about multigraphs
			//  so, randomize several times, reducing the number of 
			//   1 and 2 cycles each time.  needs logD total repetitions
			//  and the total number of calls to random member 
			//   is N + O(D logD)
			//
			// study study study
			//  O(D to the k) k cycles perhaps O(D^(k less 1) (k choose two)).
			//   as N goes to infinity and beyond 
			//    when n is small the number of k cycles is larger
			//                                                              
			//        
			// initial list of members to randomize;
			num randcalls = 0;
			// randomize a subset of the endpoints pool 
			for (g = 0; g < endpoints.size(); g++) {
				num elt = endpoints[g];
				num r = ray::Prhymeum.numbereum(endpoints.size());
				randcalls++;
				endpoints[g] = endpoints[r];
				endpoints[r] = elt;
			}
			for (g = 0; g + k < endpoints.size(); g++) {
				ums* cl = new ums;
				for (num c = 0; c < k; c++) {
					// a literal in a clause has two parts
					(*cl).add(1); // +
					(*cl).add(endpoints[g + c]);    // bit h og g  is ON 
				}
				clauses.add(cl);
			}

			printf("F");
			fprintf(colorfile, "\nc Monotone k %u D %u reg N %u cnf ", k, D, N);
			fprintf(colorfile, "\np one %u %u", N, clauses.size()); // 
			for (g = 0; g < clauses.size(); g++) {
				fprintf(colorfile, "\n");
				fprintums(colorfile, *clauses[g]);
			}
			fprintf(colorfile, "\n");
			fprintf(colorfile, "\n");
			printf("W");
			for (g = 0; g < clauses.size(); g++) {
				delete clauses[g];
				clauses[g] = NULL;
			}
			clauses.setsize(0);
			printf("D");
			////////////////////////////////
		}
	}
}
//////////////////////////////////
FILE* graph::colorfile = NULL;
umums graph::clauses;


//       elementarylibrary
//       C2
//       C3 C4 C5  for 345 coloring    
//        
//       C3 some D6 are C3 colorable   otherwise only C3D5  
//         N30  thru N70        C3D5 N180 produced mostly 180 of 180      
//      C4 (numerous files with numerous informulas) D6 D7 D8 D9 D6 thru D9 
//      C5 D10 D11 D12 D13  the  p veg  is always included Before the  informula 
//      all elementarygraph calls require an open colorfile (open file limit of ten)

num elementlibrary(char*& fname, num C, num D, num N, num qty)
{ //
	graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, fname, "a+");
	when(graph::colorfile)	fprintf(graph::colorfile, "\nc the elementary library %s, %u informulas ", fname, qty);
	graph::elementarygraph(C, D, N, qty);
	when(graph::colorfile)	fclose(graph::colorfile);
	return 0;
}
num N180library()
{ //
	num C = 3;
	num D = 5;
	num N = 180;
	num qty = 1;
	fclose(graph::colorfile);
	return zero;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//       C3 C4 C5  for 345 coloring    
//       D3 D4 D5  for 345 coloring    of these degrees
//       N3 N4 N5  
//       N6 N7 N8
//       N9  N10 N11
//       N12 N13 N14
//       N15 N16 N17
//       N18 N19 N20 
//

num C3library()
{

	num C = 3;
	num D = 2;
	num N = 3;
	num qty = N * N;
	D = 2;
	for (num en = 3; en < 20; en++) { // 
		N = en; qty = N * N;
		char* comment = new char[1000];
		sprintf_s(comment, 1000, "C3D%uN%u.veg", D, N);
		printf("\n   %s", comment);
		elementlibrary(comment, C, D, N, qty);
	}
	for (num en = 21; en < 42; en += 1) { // 
		N = en; qty = N;
		char* comment = new char[1000];
		sprintf_s(comment, 1000, "C3D%uN%u.veg", D, N);
		printf("\n   %s", comment);
		elementlibrary(comment, C, D, N, qty);
	}
	D = 3;
	for (num en = 3; en < 21; en++) { // 
		N = en; qty = N * N;
		char* comment = new char[1000];
		sprintf_s(comment, 1000, "C3D%uN%u.veg", D, N);
		printf("\n   %s", comment);
		elementlibrary(comment, C, D, N, qty);
	}
	for (num en = 21; en <= 30; en++) { // 
		N = en; qty = N;
		char* comment = new char[1000];
		sprintf_s(comment, 1000, "C3D%uN%u.veg", D, N);
		printf("\n   %s", comment);
		elementlibrary(comment, C, D, N, qty);
	}

	//N180library();

	return zero;
}
num C3library4()
{

	num C = 3;
	num D = 4;
	num N = 3;
	num qty = N * N;
	D = 4;
	for (num en = 3; en < 31; en++) { // 
		N = en; qty = N * N;
		char* comment = new char[1000];
		sprintf_s(comment, 1000, "C3D%uN%u.veg", D, N);
		printf("\n   %s", comment);
		elementlibrary(comment, C, D, N, qty);
	}
	for (num en = 31; en < 51; en += 1) { // 
		N = en; qty = N;
		char* comment = new char[1000];
		sprintf_s(comment, 1000, "C3D%uN%u.veg", D, N);
		printf("\n   %s", comment);
		elementlibrary(comment, C, D, N, qty);
	}

	//N180library();

	return zero;
}
num C3library5()
{

	num C = 3;
	num D = 5;
	num N = 3;
	num qty = N * N;
	D = 5;
	for (num en = 3; en < 31; en++) { // 
		N = en; qty = N * N;
		char* comment = new char[1000];
		sprintf_s(comment, 1000, "C3D%uN%u.veg", D, N);
		printf("\n   %s", comment);
		elementlibrary(comment, C, D, N, qty);
	}
	for (num en = 90; en < 181; en += 30) { // 
		N = en; qty = N;
		char* comment = new char[1000];
		sprintf_s(comment, 1000, "C3D%uN%u.veg", D, N);
		printf("\n   %s", comment);
		elementlibrary(comment, C, D, N, qty);
	}
	return zero;
}

num hypercubelibrary()
{
	num C = 0;
	num D = 0;
	num N = 0;
	//graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, "N1.veg", "a+");
	graph::elementarygraph(0, 0, 1, 1);
	graph::elementarygraph(1, 0, 1, 1);
	graph::elementarygraph(1, 2, 1, 1);

	fclose(graph::colorfile);
	return zero;
}

num N0library()
{
	num C = 0;
	num D = 0;
	num N = 0;
	graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, "N0.veg", "a+");
	graph::elementarygraph(0, 0, N, 1);
	graph::elementarygraph(0, 1, N, 1);
	graph::elementarygraph(1, 0, N, 1);
	graph::elementarygraph(1, 1, N, 1);
	graph::elementarygraph(1, 2, N, 1);
	graph::elementarygraph(2, 1, N, 1);
	when (graph::colorfile) fclose(graph::colorfile);
	return zero;
}
num N1library()
{
	num C = 0;
	num D = 0;
	num N = 1;
	graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, "N1.veg", "a+");
	graph::elementarygraph(0, 0, N, 1);
	graph::elementarygraph(0, 1, N, 1);
	graph::elementarygraph(1, 0, N, 1);
	graph::elementarygraph(1, 1, N, 1);
	graph::elementarygraph(1, 2, N, 1);
	graph::elementarygraph(2, 0, N, 1);
	graph::elementarygraph(2, 1, N, 1);
	graph::elementarygraph(2, 2, N, 1);
	graph::elementarygraph(3, 0, N, 1);
	graph::elementarygraph(3, 1, N, 1);
	graph::elementarygraph(3, 2, N, 1);
	graph::elementarygraph(3, 3, N, 1);
	graph::elementarygraph(4, 0, N, 1);
	graph::elementarygraph(4, 1, N, 1);
	graph::elementarygraph(4, 2, N, 1);
	graph::elementarygraph(4, 3, N, 1);
	graph::elementarygraph(4, 4, N, 1);
	graph::elementarygraph(5, 0, N, 1);
	graph::elementarygraph(5, 1, N, 1);
	graph::elementarygraph(5, 2, N, 1);
	graph::elementarygraph(5, 3, N, 1);
	graph::elementarygraph(5, 4, N, 1);
	graph::elementarygraph(6, 0, N, 1);
	graph::elementarygraph(6, 1, N, 1);
	graph::elementarygraph(6, 2, N, 1);
	graph::elementarygraph(6, 3, N, 1);
	graph::elementarygraph(6, 4, N, 1);
	graph::elementarygraph(7, 0, N, 1);
	graph::elementarygraph(7, 1, N, 1);
	graph::elementarygraph(7, 2, N, 1);
	graph::elementarygraph(7, 3, N, 1);
	graph::elementarygraph(7, 4, N, 1);
	graph::elementarygraph(8, 0, N, 1);
	graph::elementarygraph(8, 1, N, 1);
	graph::elementarygraph(8, 2, N, 1);
	graph::elementarygraph(8, 3, N, 1);
	graph::elementarygraph(8, 4, N, 1);
	when(graph::colorfile)	fclose(graph::colorfile);
	return zero;
}
num N2library()
{
	num C = 0;
	num D = 0;
	num N = 2;
	graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, "N2.veg", "a+");
	graph::elementarygraph(0, 0, N, 1);
	graph::elementarygraph(0, 1, N, 1);
	graph::elementarygraph(0, 2, N, 1);
	graph::elementarygraph(0, 3, N, 1);
	graph::elementarygraph(1, 0, N, 1);
	graph::elementarygraph(1, 1, N, 1);
	graph::elementarygraph(1, 2, N, 1);
	graph::elementarygraph(1, 3, N, 1);
	graph::elementarygraph(2, 0, N, 1);
	graph::elementarygraph(2, 1, N, 1);
	graph::elementarygraph(2, 2, N, 1);
	graph::elementarygraph(2, 3, N, 1);
	graph::elementarygraph(3, 0, N, 1);
	graph::elementarygraph(3, 1, N, 1);
	graph::elementarygraph(3, 2, N, 1);
	graph::elementarygraph(3, 3, N, 1);
	graph::elementarygraph(4, 0, N, 1);
	graph::elementarygraph(4, 1, N, 1);
	graph::elementarygraph(4, 2, N, 1);
	graph::elementarygraph(4, 3, N, 1);
	graph::elementarygraph(4, 4, N, 1);
	graph::elementarygraph(5, 0, N, 1);
	graph::elementarygraph(5, 1, N, 1);
	graph::elementarygraph(5, 2, N, 1);
	graph::elementarygraph(5, 3, N, 1);
	graph::elementarygraph(5, 4, N, 1);
	graph::elementarygraph(6, 0, N, 1);
	graph::elementarygraph(6, 1, N, 1);
	graph::elementarygraph(6, 2, N, 1);
	graph::elementarygraph(6, 3, N, 1);
	graph::elementarygraph(6, 4, N, 1);
	graph::elementarygraph(7, 0, N, 1);
	graph::elementarygraph(7, 1, N, 1);
	graph::elementarygraph(7, 2, N, 1);
	graph::elementarygraph(7, 3, N, 1);
	graph::elementarygraph(7, 4, N, 1);
	graph::elementarygraph(8, 0, N, 1);
	graph::elementarygraph(8, 1, N, 1);
	graph::elementarygraph(8, 2, N, 1);
	graph::elementarygraph(8, 3, N, 1);
	graph::elementarygraph(8, 4, N, 1);
	when(graph::colorfile)	fclose(graph::colorfile);
	return zero;
}
num N3library()
{
	num C = 0;
	num D = 0;
	num N = 3;
	graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, "N3.veg", "a+");
	graph::elementarygraph(0, 0, N, 1);
	graph::elementarygraph(0, 1, N, 1);
	graph::elementarygraph(0, 2, N, 1);
	graph::elementarygraph(0, 3, N, 1);
	graph::elementarygraph(1, 0, N, 1);
	graph::elementarygraph(1, 1, N, 1);
	graph::elementarygraph(1, 2, N, 1);
	graph::elementarygraph(1, 3, N, 1);
	graph::elementarygraph(2, 0, N, 1);
	graph::elementarygraph(2, 1, N, 1);
	graph::elementarygraph(2, 2, N, 1);
	graph::elementarygraph(2, 3, N, 1);
	graph::elementarygraph(3, 0, N, 1);
	graph::elementarygraph(3, 1, N, 1);
	graph::elementarygraph(3, 2, N, 1);
	graph::elementarygraph(3, 3, N, 1);
	graph::elementarygraph(4, 0, N, 1);
	graph::elementarygraph(4, 1, N, 1);
	graph::elementarygraph(4, 2, N, 1);
	graph::elementarygraph(4, 3, N, 1);
	graph::elementarygraph(4, 4, N, 1);
	graph::elementarygraph(5, 0, N, 1);
	graph::elementarygraph(5, 1, N, 1);
	graph::elementarygraph(5, 2, N, 1);
	graph::elementarygraph(5, 3, N, 1);
	graph::elementarygraph(5, 4, N, 1);
	graph::elementarygraph(6, 0, N, 1);
	graph::elementarygraph(6, 1, N, 1);
	graph::elementarygraph(6, 2, N, 1);
	graph::elementarygraph(6, 3, N, 1);
	graph::elementarygraph(6, 4, N, 1);
	graph::elementarygraph(7, 0, N, 1);
	graph::elementarygraph(7, 1, N, 1);
	graph::elementarygraph(7, 2, N, 1);
	graph::elementarygraph(7, 3, N, 1);
	graph::elementarygraph(7, 4, N, 1);
	graph::elementarygraph(8, 0, N, 1);
	graph::elementarygraph(8, 1, N, 1);
	graph::elementarygraph(8, 2, N, 1);
	graph::elementarygraph(8, 3, N, 1);
	graph::elementarygraph(8, 4, N, 1);
	when(graph::colorfile)	fclose(graph::colorfile);
	return zero;
}
num N4library()
{
	num C = 0;
	num D = 0;
	num N = 4;
	graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, "N4.veg", "a+");
	graph::elementarygraph(0, 0, N, 1);
	graph::elementarygraph(0, 1, N, 1);
	graph::elementarygraph(0, 2, N, 1);
	graph::elementarygraph(0, 3, N, 1);
	graph::elementarygraph(1, 0, N, 1);
	graph::elementarygraph(1, 1, N, 1);
	graph::elementarygraph(1, 2, N, 1);
	graph::elementarygraph(1, 3, N, 1);
	graph::elementarygraph(2, 0, N, 1);
	graph::elementarygraph(2, 1, N, 1);
	graph::elementarygraph(2, 2, N, 1);
	graph::elementarygraph(2, 3, N, 1);
	graph::elementarygraph(3, 0, N, 1);
	graph::elementarygraph(3, 1, N, 1);
	graph::elementarygraph(3, 2, N, 1);
	graph::elementarygraph(3, 3, N, 1);
	graph::elementarygraph(4, 0, N, 1);
	graph::elementarygraph(4, 1, N, 1);
	graph::elementarygraph(4, 2, N, 1);
	graph::elementarygraph(4, 3, N, 1);
	graph::elementarygraph(4, 4, N, 1);
	graph::elementarygraph(5, 0, N, 1);
	graph::elementarygraph(5, 1, N, 1);
	graph::elementarygraph(5, 2, N, 1);
	graph::elementarygraph(5, 3, N, 1);
	graph::elementarygraph(5, 4, N, 1);
	graph::elementarygraph(6, 0, N, 1);
	graph::elementarygraph(6, 1, N, 1);
	graph::elementarygraph(6, 2, N, 1);
	graph::elementarygraph(6, 3, N, 1);
	graph::elementarygraph(6, 4, N, 1);
	graph::elementarygraph(7, 0, N, 1);
	graph::elementarygraph(7, 1, N, 1);
	graph::elementarygraph(7, 2, N, 1);
	graph::elementarygraph(7, 3, N, 1);
	graph::elementarygraph(7, 4, N, 1);
	graph::elementarygraph(8, 0, N, 1);
	graph::elementarygraph(8, 1, N, 1);
	graph::elementarygraph(8, 2, N, 1);
	graph::elementarygraph(8, 3, N, 1);
	graph::elementarygraph(8, 4, N, 1);
	when(graph::colorfile)	fclose(graph::colorfile);
	return zero;
}
num N5library()
{
	num C = 0;
	num D = 0;
	num N = 5;
	graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, "N5.veg", "a+");
	graph::elementarygraph(0, 0, N, 1);
	graph::elementarygraph(0, 1, N, 1);
	graph::elementarygraph(0, 2, N, 1);
	graph::elementarygraph(0, 3, N, 1);
	graph::elementarygraph(1, 0, N, 1);
	graph::elementarygraph(1, 1, N, 1);
	graph::elementarygraph(1, 2, N, 1);
	graph::elementarygraph(1, 3, N, 1);
	graph::elementarygraph(2, 0, N, 1);
	graph::elementarygraph(2, 1, N, 1);
	graph::elementarygraph(2, 2, N, 1);
	graph::elementarygraph(2, 3, N, 1);
	graph::elementarygraph(3, 0, N, 1);
	graph::elementarygraph(3, 1, N, 1);
	graph::elementarygraph(3, 2, N, 1);
	graph::elementarygraph(3, 3, N, 1);
	graph::elementarygraph(4, 0, N, 1);
	graph::elementarygraph(4, 1, N, 1);
	graph::elementarygraph(4, 2, N, 1);
	graph::elementarygraph(4, 3, N, 1);
	graph::elementarygraph(4, 4, N, 1);
	graph::elementarygraph(5, 0, N, 1);
	graph::elementarygraph(5, 1, N, 1);
	graph::elementarygraph(5, 2, N, 1);
	graph::elementarygraph(5, 3, N, 1);
	graph::elementarygraph(5, 4, N, 1);
	graph::elementarygraph(6, 0, N, 1);
	graph::elementarygraph(6, 1, N, 1);
	graph::elementarygraph(6, 2, N, 1);
	graph::elementarygraph(6, 3, N, 1);
	graph::elementarygraph(6, 4, N, 1);
	graph::elementarygraph(7, 0, N, 1);
	graph::elementarygraph(7, 1, N, 1);
	graph::elementarygraph(7, 2, N, 1);
	graph::elementarygraph(7, 3, N, 1);
	graph::elementarygraph(7, 4, N, 1);
	graph::elementarygraph(8, 0, N, 1);
	graph::elementarygraph(8, 1, N, 1);
	graph::elementarygraph(8, 2, N, 1);
	graph::elementarygraph(8, 3, N, 1);
	graph::elementarygraph(8, 4, N, 1);
	when(graph::colorfile)	fclose(graph::colorfile);
	return zero;
}
num N6library()
{
	num C = 0;
	num D = 0;
	num N = 6;
	graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, "N6.veg", "a+");
	graph::elementarygraph(0, 0, N, 1);
	graph::elementarygraph(0, 1, N, 1);
	graph::elementarygraph(0, 2, N, 1);
	graph::elementarygraph(0, 3, N, 1);
	graph::elementarygraph(1, 0, N, 1);
	graph::elementarygraph(1, 1, N, 1);
	graph::elementarygraph(1, 2, N, 1);
	graph::elementarygraph(1, 3, N, 1);
	graph::elementarygraph(2, 0, N, 1);
	graph::elementarygraph(2, 1, N, 1);
	graph::elementarygraph(2, 2, N, 1);
	graph::elementarygraph(2, 3, N, 1);
	graph::elementarygraph(3, 0, N, 1);
	graph::elementarygraph(3, 1, N, 1);
	graph::elementarygraph(3, 2, N, 1);
	graph::elementarygraph(3, 3, N, 1);
	graph::elementarygraph(4, 0, N, 1);
	graph::elementarygraph(4, 1, N, 1);
	graph::elementarygraph(4, 2, N, 1);
	graph::elementarygraph(4, 3, N, 1);
	graph::elementarygraph(4, 4, N, 1);
	graph::elementarygraph(5, 0, N, 1);
	graph::elementarygraph(5, 1, N, 1);
	graph::elementarygraph(5, 2, N, 1);
	graph::elementarygraph(5, 3, N, 1);
	graph::elementarygraph(5, 4, N, 1);
	graph::elementarygraph(6, 0, N, 1);
	graph::elementarygraph(6, 1, N, 1);
	graph::elementarygraph(6, 2, N, 1);
	graph::elementarygraph(6, 3, N, 1);
	graph::elementarygraph(6, 4, N, 1);
	graph::elementarygraph(7, 0, N, 1);
	graph::elementarygraph(7, 1, N, 1);
	graph::elementarygraph(7, 2, N, 1);
	graph::elementarygraph(7, 3, N, 1);
	graph::elementarygraph(7, 4, N, 1);
	graph::elementarygraph(8, 0, N, 1);
	graph::elementarygraph(8, 1, N, 1);
	graph::elementarygraph(8, 2, N, 1);
	graph::elementarygraph(8, 3, N, 1);
	graph::elementarygraph(8, 4, N, 1);
	when(graph::colorfile)	fclose(graph::colorfile);
	return zero;
}
num N7library()
{
	num C = 0;
	num D = 0;
	num N = 7;
	graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, "N7.veg", "a+");
	graph::elementarygraph(0, 0, N, 1);
	graph::elementarygraph(0, 1, N, 1);
	graph::elementarygraph(0, 2, N, 1);
	graph::elementarygraph(0, 3, N, 1);
	graph::elementarygraph(1, 0, N, 1);
	graph::elementarygraph(1, 1, N, 1);
	graph::elementarygraph(1, 2, N, 1);
	graph::elementarygraph(1, 3, N, 1);
	graph::elementarygraph(2, 0, N, 1);
	graph::elementarygraph(2, 1, N, 1);
	graph::elementarygraph(2, 2, N, 1);
	graph::elementarygraph(2, 3, N, 1);
	graph::elementarygraph(3, 0, N, 1);
	graph::elementarygraph(3, 1, N, 1);
	graph::elementarygraph(3, 2, N, 1);
	graph::elementarygraph(3, 3, N, 1);
	graph::elementarygraph(4, 0, N, 1);
	graph::elementarygraph(4, 1, N, 1);
	graph::elementarygraph(4, 2, N, 1);
	graph::elementarygraph(4, 3, N, 1);
	graph::elementarygraph(4, 4, N, 1);
	graph::elementarygraph(5, 0, N, 1);
	graph::elementarygraph(5, 1, N, 1);
	graph::elementarygraph(5, 2, N, 1);
	graph::elementarygraph(5, 3, N, 1);
	graph::elementarygraph(5, 4, N, 1);
	graph::elementarygraph(6, 0, N, 1);
	graph::elementarygraph(6, 1, N, 1);
	graph::elementarygraph(6, 2, N, 1);
	graph::elementarygraph(6, 3, N, 1);
	graph::elementarygraph(6, 4, N, 1);
	graph::elementarygraph(7, 0, N, 1);
	graph::elementarygraph(7, 1, N, 1);
	graph::elementarygraph(7, 2, N, 1);
	graph::elementarygraph(7, 3, N, 1);
	graph::elementarygraph(7, 4, N, 1);
	graph::elementarygraph(8, 0, N, 1);
	graph::elementarygraph(8, 1, N, 1);
	graph::elementarygraph(8, 2, N, 1);
	graph::elementarygraph(8, 3, N, 1);
	graph::elementarygraph(8, 4, N, 1);
	when(graph::colorfile)	fclose(graph::colorfile);
	return zero;
}
num N8library()
{
	num C = 0;
	num D = 0;
	num N = 8;
	graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, "N8.veg", "a+");
	graph::elementarygraph(0, 0, N, 1);
	graph::elementarygraph(0, 1, N, 1);
	graph::elementarygraph(0, 2, N, 1);
	graph::elementarygraph(0, 3, N, 1);
	graph::elementarygraph(1, 0, N, 1);
	graph::elementarygraph(1, 1, N, 1);
	graph::elementarygraph(1, 2, N, 1);
	graph::elementarygraph(1, 3, N, 1);
	graph::elementarygraph(2, 0, N, 1);
	graph::elementarygraph(2, 1, N, 1);
	graph::elementarygraph(2, 2, N, 1);
	graph::elementarygraph(2, 3, N, 1);
	graph::elementarygraph(3, 0, N, 1);
	graph::elementarygraph(3, 1, N, 1);
	graph::elementarygraph(3, 2, N, 1);
	graph::elementarygraph(3, 3, N, 1);
	graph::elementarygraph(4, 0, N, 1);
	graph::elementarygraph(4, 1, N, 1);
	graph::elementarygraph(4, 2, N, 1);
	graph::elementarygraph(4, 3, N, 1);
	graph::elementarygraph(4, 4, N, 1);
	graph::elementarygraph(5, 0, N, 1);
	graph::elementarygraph(5, 1, N, 1);
	graph::elementarygraph(5, 2, N, 1);
	graph::elementarygraph(5, 3, N, 1);
	graph::elementarygraph(5, 4, N, 1);
	graph::elementarygraph(6, 0, N, 1);
	graph::elementarygraph(6, 1, N, 1);
	graph::elementarygraph(6, 2, N, 1);
	graph::elementarygraph(6, 3, N, 1);
	graph::elementarygraph(6, 4, N, 1);
	graph::elementarygraph(7, 0, N, 1);
	graph::elementarygraph(7, 1, N, 1);
	graph::elementarygraph(7, 2, N, 1);
	graph::elementarygraph(7, 3, N, 1);
	graph::elementarygraph(7, 4, N, 1);
	graph::elementarygraph(8, 0, N, 1);
	graph::elementarygraph(8, 1, N, 1);
	graph::elementarygraph(8, 2, N, 1);
	graph::elementarygraph(8, 3, N, 1);
	graph::elementarygraph(8, 4, N, 1);
	when(graph::colorfile)	fclose(graph::colorfile);
	return zero;
}
num N9library()
{
	num C = 0;
	num D = 0;
	num N = 9;
	graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, "N9.veg", "a+");
	graph::elementarygraph(0, 0, N, 1);
	graph::elementarygraph(0, 1, N, 1);
	graph::elementarygraph(0, 2, N, 1);
	graph::elementarygraph(0, 3, N, 1);
	graph::elementarygraph(1, 0, N, 1);
	graph::elementarygraph(1, 1, N, 1);
	graph::elementarygraph(1, 2, N, 1);
	graph::elementarygraph(1, 3, N, 1);
	graph::elementarygraph(2, 0, N, 1);
	graph::elementarygraph(2, 1, N, 1);
	graph::elementarygraph(2, 2, N, 1);
	graph::elementarygraph(2, 3, N, 1);
	graph::elementarygraph(3, 0, N, 1);
	graph::elementarygraph(3, 1, N, 1);
	graph::elementarygraph(3, 2, N, 1);
	graph::elementarygraph(3, 3, N, 1);
	graph::elementarygraph(4, 0, N, 1);
	graph::elementarygraph(4, 1, N, 1);
	graph::elementarygraph(4, 2, N, 1);
	graph::elementarygraph(4, 3, N, 1);
	graph::elementarygraph(4, 4, N, 1);
	graph::elementarygraph(5, 0, N, 1);
	graph::elementarygraph(5, 1, N, 1);
	graph::elementarygraph(5, 2, N, 1);
	graph::elementarygraph(5, 3, N, 1);
	graph::elementarygraph(5, 4, N, 1);
	graph::elementarygraph(6, 0, N, 1);
	graph::elementarygraph(6, 1, N, 1);
	graph::elementarygraph(6, 2, N, 1);
	graph::elementarygraph(6, 3, N, 1);
	graph::elementarygraph(6, 4, N, 1);
	graph::elementarygraph(7, 0, N, 1);
	graph::elementarygraph(7, 1, N, 1);
	graph::elementarygraph(7, 2, N, 1);
	graph::elementarygraph(7, 3, N, 1);
	graph::elementarygraph(7, 4, N, 1);
	graph::elementarygraph(8, 0, N, 1);
	graph::elementarygraph(8, 1, N, 1);
	graph::elementarygraph(8, 2, N, 1);
	graph::elementarygraph(8, 3, N, 1);
	graph::elementarygraph(8, 4, N, 1);
	when(graph::colorfile) fclose(graph::colorfile);
	return zero;
}
num Ntenlibrary()
{
	num C = 0;
	num D = 0;
	num N = 9;
	graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, "hypercubes.veg", "a+");
	graph::elementarygraph(4, 3, 4, 1);
	graph::elementarygraph(4, 4, 8, 1);
	graph::elementarygraph(5, 4, 8, 1);
	graph::elementarygraph(6, 4, 8, 1);
	graph::elementarygraph(7, 4, 8, 1);
	graph::elementarygraph(8, 4, 8, 1);
	graph::elementarygraph(2, 4, 16, 1);
	graph::elementarygraph(3, 4, 16, 1);
	graph::elementarygraph(4, 4, 16, 1);
	graph::elementarygraph(5, 4, 16, 1);
	graph::elementarygraph(6, 4, 16, 1);
	//graph::elementarygraph(7, 4, 16, 1);
	//graph::elementarygraph(8, 4, 16, 1);
	graph::elementarygraph(2, 5, 32, 1);
	graph::elementarygraph(3, 5, 32, 1);
	graph::elementarygraph(4, 5, 32, 1);
	graph::elementarygraph(5, 5, 32, 1);
	//graph::elementarygraph(6, 5, 32, 1);
	//graph::elementarygraph(7, 5, 32, 1);
	//graph::elementarygraph(8, 5, 32, 1);
	when(graph::colorfile)	fclose(graph::colorfile);
	return zero;
}
num elementarylibrary()
{
	// want single formula of all elementary graphs with lessthan ten vertys
	// CjDkNg where selfloops are ignored 
	N0library();
	N1library();
	N2library();
	N3library();
	N4library();
	N5library();
	N6library();
	N7library();
	N8library();
	N9library();
 //Ntenlibrary();
	return zero;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////// random regular graphs /////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main(num argc, char* argv[])
{
 {
 char fname[] = "disrib2022.gob";
	//ray::Prhymeum.reseed();
	//mainbag();
	//return 0;
	for(num g = zero;g<7;g++)ray::Prhymeum.randumprime();
 //ray::Prhymeum.lithiumstream();
 printf("\n\n");
	//ray::Prhymeum.betteum(fname);
 }
	// distrib 2020
	////////////////////////////////
 //Prhymeum.closeum();
	ray::Prhymeum.reseed();
	//ray::Prhymeum.lithiumstream();
 ///Prhymeum.closeum();
 //return 0;
	//Prhymeum.lithiumstream();//never ending stream of one through nine with double zero testing 
	//elementarylibrary();
	//N0library();
	//N1library();
	//N2library();
	//N3library();
	//N4library();
	//N5library();
	//N6library();
	//N7library();
 // medium n 334480117 
  //small n
		num q = 1000;
		num C = 3;
		num D = 5;
		num N = 60;
  for(num nnn = 60; nnn <= N; nnn++)
		for (num g = 0; g < 10; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%uN%u_%u.veg", C, D, nnn, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, nnn, q); //graph::ezcolorgraph(4, 9, 150, q);
			when(graph::colorfile)	fclose(graph::colorfile);
		} 
		ray::Prhymeum.closeum();
		return 0;
  C=4; D=6; 
  N=25;
		for (num nnn = 16; nnn < N; nnn++)
  for (num g = 0; g < 1; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%uN%u_%u.veg", C, D, nnn, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, nnn, C * D * N); //graph::ezcolorgraph(4, 9, 150, q);
			when(graph::colorfile)	fclose(graph::colorfile);
		}
  C=4; D=7; N=29;
		for (num nnn = 22; nnn < N; nnn++)
		for (num g = 0; g < 1; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%uN%u_%u.veg", C, D, nnn, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, nnn, one+C * D * N); //graph::ezcolorgraph(4, 9, 150, q);
			when(graph::colorfile)	fclose(graph::colorfile);
		}
		C = 4; D = 8; N = 41;
		for (num nnn = 32; nnn < N; nnn++)
		for (num g = 0; g < 1; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%uN%u_%u.veg", C, D, nnn, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, nnn, D * N); //graph::ezcolorgraph(4, 9, 150, q);
			when(graph::colorfile)	fclose(graph::colorfile);
		}
		C = 4; D = 9; N = 82;
  for(num nnn = 45; nnn < N; nnn +=9)
		for (num g = 0; g < 1; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%uN%u_%u.veg", C, D, nnn, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, nnn, C * N); //graph::ezcolorgraph(4, 9, 150, q);
			when(graph::colorfile)	fclose(graph::colorfile);
		}
		ray::Prhymeum.closeum();
		return 0;

		C = 4; D = 6; N = 42;
		for (num g = 0; g < 1; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%uN%u_%u.veg", C, D, N, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, N, 1000); //graph::ezcolorgraph(4, 9, 150, q);
			when(graph::colorfile)	fclose(graph::colorfile);
		}
		C = 4; D = 7; N = 51;
		for (num g = 0; g < 1; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%uN%u_%u.veg", C, D, N, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, N + g, q); //graph::ezcolorgraph(4, 9, 150, q);
			when(graph::colorfile)	fclose(graph::colorfile);
		}
		C = 4; D = 8; N = 80;
		for (num g = 0; g < 1; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%uN%u_%u.veg", C, D, N, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, N + g, q); //graph::ezcolorgraph(4, 9, 150, q);
			when(graph::colorfile)	fclose(graph::colorfile);
		}
		C = 4; D = 9; N = 117;
		when(0)
			for (num g = 0; g < 1; g++) {
				char* colfilename = new char[1000];
				sprintf_s(colfilename, 1000, "c%ud%uN%u_%u.veg", C, D, N, g);
				graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
				graph::ezcolorgraph(C, D, N + g, q); //graph::ezcolorgraph(4, 9, 150, q);
				when(graph::colorfile)	fclose(graph::colorfile);
			}
		C = 5; D = 10; N = 34;
		for (num g = 0; g < 1; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%uN%u_%u.veg", C, D, N, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, N + g, q); //graph::ezcolorgraph(4, 9, 150, q);
			fclose(graph::colorfile);
		}
		C = 5; D = 11; N = 48;
		for (num g = 0; g < 1; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%uN%u_%u.veg", C, D, N, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, N + g, q); //graph::ezcolorgraph(4, 9, 150, q);
			fclose(graph::colorfile);
		}
		C = 5; D = 12; N = 60;
		for (num g = 0; g < 1; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%uN%u_%u.veg", C, D, N, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, N + g, q); //graph::ezcolorgraph(4, 9, 150, q);
			fclose(graph::colorfile);
		}
		return zero; N = 32;
		for (num g = 0; g < 10; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%un%u_%u.veg", C, D, N, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, N + g, q); //graph::ezcolorgraph(4, 9, 150, q);
			fclose(graph::colorfile);
		}  N = 33;
		for (num g = 0; g < 10; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%un%u_%u.veg", C, D, N, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, N + g, q); //graph::ezcolorgraph(4, 9, 150, q);
			fclose(graph::colorfile);
		} N = 42;
		for (num g = 0; g < 10; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%un%u_%u.veg", C, D, N, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, N + g, q); //graph::ezcolorgraph(4, 9, 150, q);
			fclose(graph::colorfile);
		}
		N = 49;
		for (num g = 0; g < 10; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%un%u_%u.veg", C, D, N, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, N + g, q); //graph::ezcolorgraph(4, 9, 150, q);
			fclose(graph::colorfile);
		}
		N = 63;
		for (num g = 0; g < 10; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%un%u_%u.veg", C, D, N, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, N + g, q); //graph::ezcolorgraph(4, 9, 150, q);
			fclose(graph::colorfile);
		}
		N = 81;
		for (num g = 0; g < 10; g++) {
			char* colfilename = new char[1000];
			sprintf_s(colfilename, 1000, "c%ud%un%u_%u.veg", C, D, N, g);
			graph::colorfile = (FILE*)zero; fopen_s(&graph::colorfile, colfilename, "a+");
			graph::ezcolorgraph(C, D, N + g, q); //graph::ezcolorgraph(4, 9, 150, q);
			fclose(graph::colorfile);
		}
		return zero;
	

	return 0;
}